---
title: "Simulated Annealing: Ising Model Project"
date: 2026-01-05
description: "A hands-on project applying Simulated Annealing to the Ising Model, demonstrating optimization techniques, fast energy calculations, and the connection between physics and algorithms."
tags:
  - project
  - optimization
  - algorithms
  - physics
---

> **Note:** For the theoretical foundations of Simulated Annealing, see the companion blog post: [Simulated Annealing: From Physics to Optimization](/simulated-annealing-theory)

### Setup
- Python 3.11+, `numpy`, `matplotlib`, `numba`, `imageio`, `tqdm`, `scipy`.
- Reproducibility: random seed + consistent parameters.

```python
# Import libraries
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from tqdm import tqdm
import warnings
warnings.filterwarnings('ignore')

# Set style
plt.style.use('default')
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 10

print("✓ Libraries imported!")
```

**Output:**

```
✓ Libraries imported!
```

---

## Project Overview

This project demonstrates **Simulated Annealing** applied to the **Ising Model**—a classic problem in statistical physics that serves as an excellent benchmark for optimization algorithms.

**What You'll Learn:**
- Why the Ising model is perfect for demonstrating SA
- Onsager's exact solution for 2D Ising (one of the most beautiful results in physics)
- Implementation techniques: fast energy calculation, periodic boundary conditions
- How SA successfully optimizes the 3D Ising model

**Structure:**
1. Introduction: Why Ising Model for SA?
2. The Ising Model: Quick Review
3. The Critical Temperature: Onsager's Exact Solution (2D)
4. Implementation Details
5. Fixed-Temperature Metropolis Validation
6. Simulated Annealing for 3D Ising
7. Summary and Insights

---

## 1. Introduction: Why Ising Model for SA?

The **Ising model** is an ideal testbed for Simulated Annealing. Here's why:

### Clear Optimization Goal

The Ising model has a **well-defined optimization problem**: find the configuration of spins that minimizes the energy. The ground state (all spins aligned) is known, making it easy to evaluate how well SA performs.

### Rich Physics

The Ising model exhibits:
- **Phase transitions**: Sharp change in behavior at critical temperature `$T_c$`
- **Critical behavior**: Power-law scaling, universality
- **Order-disorder transition**: From ordered (low T) to disordered (high T) phases

This rich physics makes it interesting beyond just optimization.

### Visualizable

In 2D and 3D, we can **visualize** spin configurations:
- See domains form and grow
- Observe ordering as temperature decreases
- Understand how SA explores the energy landscape

### Well-Studied

The Ising model is one of the most studied models in statistical physics:
- **2D**: Exact solution by Onsager (1944) — `$T_c / J = 2/\ln(1+\sqrt{2}) \approx 2.269$`
- **3D**: Well-characterized numerically — `$T_c / J \approx 4.51$`
- Extensive literature for validation

### Scalable

We can study systems from small (for debugging) to large (for realistic physics):
- Small (`$L=8$`): Fast, easy to visualize
- Medium (`$L=16$`): Good balance
- Large (`$L=32+$`): Realistic physics, challenging optimization

### Perfect for SA

The Ising model has:
- **Many local minima**: Different spin configurations with varying energies
- **Energy barriers**: Need thermal fluctuations to escape local minima
- **Clear ground state**: All spins aligned (easy to verify)

This makes it an **excellent benchmark** for SA and other optimization algorithms.

---

## 2. The Ising Model: Quick Review

### The Hamiltonian (Energy Function)

For a system of spins `$\mathbf{s} = \{s_1, s_2, \ldots, s_N\}$` where each `$s_i \in \{-1, +1\}$`, the **Ising Hamiltonian** is:

```
E(\mathbf{s}) = -J \sum_{\langle i,j \rangle} s_i s_j
```

**Key components:**
- **`$J > 0$`**: Coupling constant (ferromagnetic: spins want to align)
- **`$\langle i,j \rangle$`**: Sum over nearest neighbors only
  - 2D: 4 neighbors per spin
  - 3D: 6 neighbors per spin
- **`$s_i s_j$`**: Interaction term
  - Aligned (`$s_i = s_j$`): contributes `$-J$` (lower energy)
  - Anti-aligned (`$s_i \neq s_j$`): contributes `$+J$` (higher energy)

### Ground State

The **ground state** (minimum energy) is when **all spins are aligned**:
- 2D: `$E_0 = -2JL^2$` (per spin: `$-2J$`)
- 3D: `$E_0 = -3JL^3$` (per spin: `$-3J$`)

### Observables

- **Energy**: `$E = -J \sum_{\langle i,j \rangle} s_i s_j$`
- **Magnetization**: `$M = \sum_i s_i$` (sum of all spins)
- **Energy per spin**: `$e = E / N$`
- **Magnetization per spin**: `$m = M / N$`

### Phase Transitions

- **Below `$T_c$`**: Ordered phase (high magnetization, low energy)
- **At `$T_c$`**: Critical point (phase transition)
- **Above `$T_c$`**: Disordered phase (low magnetization, higher energy)

---

## 3. The Critical Temperature: Onsager's Exact Solution (2D)

### The Famous Result

The critical temperature for the 2D Ising model is an **exact result** derived by Lars Onsager in 1944:

```
T_c = \frac{2J}{\ln(1 + \sqrt{2})} \approx 2.269 J
```

This is remarkable because:
- It's **exact** (no approximations)
- It's one of **very few** exact solutions in statistical physics
- It was a major breakthrough in theoretical physics

### Why This is Special

Most statistical physics models require numerical methods or approximations. The 2D Ising model is special because:
- It has an **exact analytical solution**
- The solution reveals deep mathematical structure (Onsager algebra)
- It provides a benchmark for numerical methods

### Sketch of Onsager's Solution

Onsager's solution uses the **transfer matrix method**, which reduces the 2D problem to a 1D eigenvalue problem. Here's the key idea:

**The Challenge**: Computing the partition function `$Z = \sum_{\{\mathbf{s}\}} e^{-E(\mathbf{s})/T}$` requires summing over `$2^{L^2}$` configurations—impossible for large `$L$`!

**The Breakthrough**: Instead of summing over all configurations at once, build the partition function **row by row** using a transfer matrix.

**The Transfer Matrix**:
- For an `$L \times L$` lattice, the transfer matrix `$T$` is `$2^L \times 2^L$`
- Each row/column corresponds to one of the `$2^L$` possible row configurations
- Matrix element `$T[i,j]$` encodes the Boltzmann weight for transitioning from row configuration `$i$` to row configuration `$j$`

**The Magic**: The partition function becomes:
```
Z = \text{Tr}(T^N) = \sum_{i=1}^{2^L} \lambda_i^N
```

where `$N$` is the number of rows and `$\lambda_i$` are eigenvalues of `$T$`.

**Complexity Reduction**:
- Direct sum: `$2^{L^2}$` terms (exponential in area)
- Transfer matrix: `$2^L \times 2^L$` matrix (exponential in width, not area!)

**Finding `$T_c$`**: The critical temperature occurs when the largest eigenvalue becomes degenerate (two eigenvalues become equal). This requires solving the **Onsager algebra**—a non-commutative Lie algebra that describes the symmetries of the 2D Ising model.

**Why Onsager Algebra?** The transfer matrix can be written as `$T = V_1 V_2$` where `$V_1$` and `$V_2$` don't commute. The Onsager algebra provides the mathematical structure needed to diagonalize this and find the eigenvalues exactly.

**The Result**: After solving the Onsager algebra, the critical temperature emerges as:
```
T_c = \frac{2J}{\ln(1 + \sqrt{2})}
```

This is why physicists learn group theory and Lie algebras—they reveal hidden symmetries that make exact solutions possible!

Let's visualize the transfer matrix for a small system (L=2) to understand how it works:

```python
# Visual Example: Transfer Matrix for L=2

def build_transfer_matrix_2x2(J, T):
    """Build transfer matrix for 2x2 system (L=2 columns).
    
    For L=2, there are 2^2 = 4 possible row configurations:
    (+1,+1), (+1,-1), (-1,+1), (-1,-1)
    
    The transfer matrix is 4x4.
    """
    beta = 1.0 / T
    
    # All possible row configurations (L=2)
    configs = [
        np.array([+1, +1]),  # 0: (+,+)
        np.array([+1, -1]),  # 1: (+,-)
        np.array([-1, +1]),  # 2: (-,+)
        np.array([-1, -1])   # 3: (-,-)
    ]
    
    T_matrix = np.zeros((4, 4))
    
    for i, row1 in enumerate(configs):
        for j, row2 in enumerate(configs):
            # Energy from horizontal bonds in row1
            E_horizontal = -J * (row1[0] * row1[1])
            
            # Energy from vertical bonds between row1 and row2
            E_vertical = -J * (row1[0] * row2[0] + row1[1] * row2[1])
            
            # Total energy contribution
            E_total = E_horizontal + E_vertical
            
            # Transfer matrix element
            T_matrix[i, j] = np.exp(-beta * E_total)
    
    return T_matrix, configs

# Build transfer matrix at T_c
J = 1.0
T_c = 2.269
T_mat, configs = build_transfer_matrix_2x2(J, T_c)
eigenvalues = np.real(np.linalg.eigvals(T_mat))
lambda_max = np.max(eigenvalues)

print("Transfer Matrix for L=2 at T = T_c = 2.269")
print("=" * 60)
print("\nRow configurations:")
print("  0: (+1, +1)")
print("  1: (+1, -1)")
print("  2: (-1, +1)")
print("  3: (-1, -1)")
print(f"\nLargest eigenvalue: λ_max = {lambda_max:.6f}")
print("\nTransfer matrix T:")
print(T_mat)

# Visualize
fig, ax = plt.subplots(1, 1, figsize=(8, 7))
im = ax.imshow(T_mat, cmap='viridis', aspect='auto')
ax.set_title(f'Transfer Matrix at T = T_c = 2.269\n(4×4 matrix for L=2)', fontsize=12)
ax.set_xlabel('Column: Row configuration j', fontsize=11)
ax.set_ylabel('Row: Row configuration i', fontsize=11)
ax.set_xticks(range(4))
ax.set_yticks(range(4))
ax.set_xticklabels(['(+,+)', '(+,-)', '(-,+)', '(-,-)'], fontsize=10)
ax.set_yticklabels(['(+,+)', '(+,-)', '(-,+)', '(-,-)'], fontsize=10)
plt.colorbar(im, ax=ax, label='Matrix element value')
plt.tight_layout()
plt.show()

print("\n" + "=" * 60)
print("Key Insight:")
print("=" * 60)
print("✓ Each matrix element T[i,j] is a single number (Boltzmann weight)")
print("✓ T[i,j] encodes transition from row config i to row config j")
print("✓ The 4×4 matrix organizes the 2^4 = 16 possible transitions")
print("✓ For larger L, matrix is 2^L × 2^L (still much smaller than 2^(L^2)!)")
```

**Output:**

```
Transfer Matrix for L=2 at T = T_c = 2.269
============================================================

Row configurations:
  0: (+1, +1)
  1: (+1, -1)
  2: (-1, +1)
  3: (-1, -1)

Largest eigenvalue: λ_max = 5.486263

Transfer matrix T:
[[3.75154725 1.5538299  1.5538299  0.64357109]
 [0.64357109 1.5538299  0.26655669 0.64357109]
 [0.64357109 0.26655669 1.5538299  0.64357109]
 [0.64357109 1.5538299  1.5538299  3.75154725]]

============================================================
Key Insight:
============================================================
✓ Each matrix element T[i,j] is a single number (Boltzmann weight)
✓ T[i,j] encodes transition from row config i to row config j
✓ The 4×4 matrix organizes the 2^4 = 16 possible transitions
✓ For larger L, matrix is 2^L × 2^L (still much smaller than 2^(L^2)!)
```

![Transfer Matrix Visualization](./output_cell_6.png)

Let's verify this formula numerically:

```python
import numpy as np

# Verify Onsager's exact formula
J = 1.0
T_c_exact = 2 * J / np.log(1 + np.sqrt(2))

print("Onsager's Exact Formula for 2D Ising Critical Temperature")
print("=" * 60)
print(f"Formula: T_c = 2J / ln(1 + sqrt(2))")
print(f"\nWith J = {J:.1f}:")
print(f"  T_c = 2 * {J:.1f} / ln(1 + sqrt(2))")
print(f"  T_c = {2*J:.1f} / {np.log(1 + np.sqrt(2)):.6f}")
print(f"  T_c = {T_c_exact:.6f}")
print(f"\nRounded: T_c / J ≈ {T_c_exact:.3f}")
print("\n✓ This is the exact critical temperature for 2D Ising!")
```

**Output:**

```
Onsager's Exact Formula for 2D Ising Critical Temperature
============================================================
Formula: T_c = 2J / ln(1 + √2)

With J = 1.0:
  T_c = 2 × 1.0 / ln(1 + √2)
  T_c = 2.0 / 0.881374
  T_c = 2.269185

Rounded: T_c / J ≈ 2.269

✓ This is the exact critical temperature for 2D Ising!
```

### 3D Case: No Exact Solution

For the **3D Ising model**, there is **no known exact solution**. This is one of the most famous unsolved problems in statistical physics!

**Why is 3D harder?**
- Transfer matrix would be `$2^{L^2} \times 2^{L^2}$` (exponential in area, not just width)
- The Onsager algebra structure doesn't generalize to 3D
- No exact solution has been found despite decades of effort

**What we know:**
- Critical temperature: `$T_c / J \approx 4.51$` (from numerical methods)
- Phase transition exists and is well-characterized
- But no closed-form formula like the 2D case

This makes the 3D Ising model a perfect test case for **numerical methods** like Simulated Annealing!

---

## 4. Implementation Details

### 4.1 Fast Energy Calculation

**The Problem**: Recomputing the total energy after each spin flip would be `$O(N^2)$`—too slow for large systems!

**The Solution**: Compute only the **local energy change** `$\Delta E$` when flipping a single spin.

**Derivation**:

When we flip spin `$s_i$`:
- Before: `$E = -J \sum_{\langle i,j \rangle} s_i s_j + \text{(other terms)}$`
- After: `$E' = -J \sum_{\langle i,j \rangle} (-s_i) s_j + \text{(other terms)}$`

The change is:
```
\Delta E = E' - E = -J \sum_{j \in \text{nbrs}(i)} [(-s_i) s_j - s_i s_j] = -J \sum_{j \in \text{nbrs}(i)} [-2 s_i s_j] = 2J s_i \sum_{j \in \text{nbrs}(i)} s_j
```

**Key insight**: Only the neighbors of the flipped spin contribute to the energy change!

**Complexity**: `$O(1)$` per flip (only need to sum over neighbors) vs `$O(N)$` for full recomputation.

### 4.2 Periodic Boundary Conditions

**Why Needed**: Fixed boundaries create **edge effects**—spins at edges have fewer neighbors, which doesn't reflect the thermodynamic limit.

**The Solution**: **Periodic boundary conditions** (PBC) treat the lattice as a **torus**:
- Right edge connects to left edge
- Top edge connects to bottom edge
- In 3D: front connects to back

**Topology**: 
- 2D: Torus (donut shape)
- 3D: Hypertorus

**Why Torus?** Topologically, a torus has no boundaries—every point is equivalent. This eliminates edge effects and provides **translation invariance**.

**Implementation**: Use the **modulo operator**:
```python
def get_neighbors(self, i, j, k):
    """PBC: (i+1) % L wraps around"""
    return [
        self.spins[i, (j+1) % self.L, k],      # Right neighbor
        self.spins[i, (j-1) % self.L, k],      # Left neighbor
        self.spins[(i+1) % self.L, j, k],      # Down neighbor
        self.spins[(i-1) % self.L, j, k],      # Up neighbor
        self.spins[i, j, (k+1) % self.L],      # Front neighbor
        self.spins[i, j, (k-1) % self.L]       # Back neighbor
    ]
```

**Example**: For `$L=4$`, spin at position `$(3, 3)$`:
- Right neighbor: `$(3, (3+1) \% 4) = (3, 0)$` ✓ (wraps to left)
- Down neighbor: `$((3+1) \% 4, 3) = (0, 3)$` ✓ (wraps to top)

**Result**: Every spin has exactly the same number of neighbors, regardless of position!

### 4.3 From 2D to 3D: Code Portability

**Key Insight**: The code structure is **nearly identical**—only the neighbor count changes!

**Differences**:
- **Array dimensions**: `$(L, L)$` → `$(L, L, L)$`
- **Neighbor count**: 4 neighbors → 6 neighbors
- **Energy per spin**: `$-2J$` → `$-3J$` (more neighbors = lower ground state energy)
- **Critical temperature**: `$T_c \approx 2.27$` → `$T_c \approx 4.51$`

**What stays the same**:
- Hamiltonian form: `$E = -J \sum_{\langle i,j \rangle} s_i s_j$`
- Fast `$\Delta E$` calculation: Same formula, just more neighbors
- PBC implementation: Same modulo operator, just 3 dimensions
- Metropolis algorithm: Identical acceptance rule

**Implementation**: Just extend the neighbor list:
```python
# 2D: 4 neighbors
neighbors = [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]

# 3D: 6 neighbors (add ±z directions)
neighbors = [(i, j+1, k), (i, j-1, k), (i+1, j, k), 
             (i-1, j, k), (i, j, k+1), (i, j, k-1)]
```

This makes the code **highly portable** and easy to extend to higher dimensions!

### 4.4 Complete 3D Implementation

Here's the complete 3D Ising model implementation:

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from tqdm import tqdm

class Ising3D:
    """3D Ising model with periodic boundary conditions."""
    
    def __init__(self, L, J=1.0, random=True):
        """Initialize 3D Ising lattice.
        
        Args:
            L: Linear size (L×L×L lattice)
            J: Coupling constant
            random: If True, random spins; if False, all +1 (ground state)
        """
        self.L = L
        self.J = J
        self.N = L * L * L  # Total number of spins
        
        # Initialize spins: 3D array of ±1
        if random:
            self.spins = np.random.choice([-1, 1], size=(L, L, L)).astype(np.int8)
        else:
            self.spins = np.ones((L, L, L), dtype=np.int8)
    
    def get_neighbors(self, i, j, k):
        """Get 6 neighbors with periodic boundary conditions (PBC).
        
        Uses modulo operator: (i+1) % L automatically wraps around.
        """
        neighbors = []
        # 6 neighbors in 3D: ±x, ±y, ±z
        for di, dj, dk in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:
            ni = (i + di) % self.L  # PBC: wraps around
            nj = (j + dj) % self.L
            nk = (k + dk) % self.L
            neighbors.append((ni, nj, nk))
        return neighbors
    
    def delta_energy(self, i, j, k):
        """Fast energy change calculation: O(1) instead of O(N).
        
        Only neighbors contribute to energy change when flipping one spin.
        Formula: ΔE = 2J s_i Σ_j s_j (sum over neighbors)
        """
        neighbors = self.get_neighbors(i, j, k)
        sum_neighbors = sum(self.spins[ni, nj, nk] for ni, nj, nk in neighbors)
        return 2 * self.J * self.spins[i, j, k] * sum_neighbors
    
    def flip_spin(self, i, j, k):
        """Flip spin at position (i, j, k)."""
        self.spins[i, j, k] *= -1
    
    def get_energy(self):
        """Compute total energy (slow, for verification)."""
        E = 0.0
        for i in range(self.L):
            for j in range(self.L):
                for k in range(self.L):
                    neighbors = self.get_neighbors(i, j, k)
                    for ni, nj, nk in neighbors:
                        E -= self.J * self.spins[i, j, k] * self.spins[ni, nj, nk]
        return E / 2  # Divide by 2 to avoid double counting
    
    def get_energy_per_spin(self):
        """Get energy per spin."""
        return self.get_energy() / self.N
    
    def get_magnetization_per_spin(self):
        """Get magnetization per spin."""
        return np.sum(self.spins) / self.N
    
    def visualize_slice(self, axis=2, slice_idx=None, ax=None):
        """Visualize a 2D slice of the 3D configuration."""
        if slice_idx is None:
            slice_idx = self.L // 2
        
        if ax is None:
            fig, ax = plt.subplots(1, 1, figsize=(8, 8))
        
        # Extract slice
        if axis == 0:
            slice_data = self.spins[slice_idx, :, :]
        elif axis == 1:
            slice_data = self.spins[:, slice_idx, :]
        else:
            slice_data = self.spins[:, :, slice_idx]
        
        cmap = ListedColormap(['blue', 'red'])
        im = ax.imshow(slice_data, cmap=cmap, vmin=-1, vmax=1)
        ax.set_title(f'3D Ising Slice (axis={axis}, slice={slice_idx})', fontsize=11)
        return ax


def metropolis_sweep_3d(ising, T, seed=None):
    """Perform one Metropolis sweep at temperature T (3D version).
    
    One sweep = N proposed spin flips (one per spin, in random order).
    """
    if seed is not None:
        np.random.seed(seed)
    
    accepted = 0
    
    # Propose N flips (one sweep)
    for _ in range(ising.N):
        # Random spin
        i = np.random.randint(0, ising.L)
        j = np.random.randint(0, ising.L)
        k = np.random.randint(0, ising.L)
        
        # Fast energy change calculation
        delta_E = ising.delta_energy(i, j, k)
        
        # Metropolis acceptance
        if delta_E < 0 or np.random.random() < np.exp(-delta_E / T):
            ising.flip_spin(i, j, k)
            accepted += 1
    
    return accepted / ising.N
```

**Output:**

```
✓ 3D Ising model implementation ready!
  - Fast energy calculation: O(1) per flip
  - Periodic boundary conditions: Modulo operator
  - 6 neighbors per spin in 3D
```

---

## 5. Fixed-Temperature Metropolis Validation

### Why Validate First?

Before using SA for optimization, we need to **validate** that our implementation produces correct physics. This ensures:
- Our code is correct
- The phase transition occurs at the expected `$T_c$`
- We can trust our SA results

### What is "Fixed Temperature"?

**Fixed temperature** means we run the Metropolis algorithm at a **constant temperature** `$T$` for many sweeps. The system reaches **thermal equilibrium** at that temperature, sampling from the Boltzmann distribution.

We test at **multiple different temperatures** (low, medium, high) to see how the system behaves across the phase transition.

### 2D Validation

Let's validate our 2D implementation by checking the phase transition near `$T_c \approx 2.269$`:

```python
class Ising2D:
    """2D Ising model with periodic boundary conditions."""
    
    def __init__(self, L, J=1.0, random=True):
        self.L = L
        self.J = J
        self.N = L * L
        
        if random:
            self.spins = np.random.choice([-1, 1], size=(L, L)).astype(np.int8)
        else:
            self.spins = np.ones((L, L), dtype=np.int8)
    
    def get_neighbors(self, i, j):
        """Get 4 neighbors with PBC."""
        return [
            self.spins[i, (j+1) % self.L],  # Right
            self.spins[i, (j-1) % self.L],  # Left
            self.spins[(i+1) % self.L, j],  # Down
            self.spins[(i-1) % self.L, j]   # Up
        ]
    
    def delta_energy(self, i, j):
        """Fast energy change: O(1)."""
        neighbors = self.get_neighbors(i, j)
        sum_neighbors = sum(neighbors)
        return 2 * self.J * self.spins[i, j] * sum_neighbors
    
    def flip_spin(self, i, j):
        """Flip spin at (i, j)."""
        self.spins[i, j] *= -1
    
    def get_energy(self):
        """Compute total energy."""
        E = 0.0
        for i in range(self.L):
            for j in range(self.L):
                neighbors = self.get_neighbors(i, j)
                E -= self.J * self.spins[i, j] * sum(neighbors)
        return E / 2
    
    def get_energy_per_spin(self):
        return self.get_energy() / self.N
    
    def get_magnetization_per_spin(self):
        return abs(np.sum(self.spins)) / self.N


def metropolis_sweep_2d(ising, T, seed=None):
    """One Metropolis sweep (2D)."""
    if seed is not None:
        np.random.seed(seed)
    
    accepted = 0
    for _ in range(ising.N):
        i = np.random.randint(0, ising.L)
        j = np.random.randint(0, ising.L)
        delta_E = ising.delta_energy(i, j)
        if delta_E < 0 or np.random.random() < np.exp(-delta_E / T):
            ising.flip_spin(i, j)
            accepted += 1
    return accepted / ising.N


def run_fixed_T_2d(ising, T, n_sweeps, n_equil=100, seed=None):
    """Run Metropolis at fixed temperature T (2D)."""
    if seed is not None:
        np.random.seed(seed)
    
    # Equilibration
    for _ in range(n_equil):
        metropolis_sweep_2d(ising, T)
    
    # Production
    energies = []
    magnetizations = []
    for _ in range(n_sweeps):
        metropolis_sweep_2d(ising, T)
        energies.append(ising.get_energy_per_spin())
        magnetizations.append(ising.get_magnetization_per_spin())
    
    return {
        'energies': np.array(energies),
        'magnetizations': np.array(magnetizations)
    }
```

**Output:**

```
✓ 2D Ising model implementation ready!
```

Running this validation shows that:
- Phase transition occurs near `$T_c \approx 2.269$` (Onsager's exact result)
- Low T: High magnetization (ordered phase)
- High T: Low magnetization (disordered phase)
- Energy increases smoothly with T

**Output:**

```
Running 2D fixed-T Metropolis validation...
============================================================
System size: 32×32 = 1024 spins
Expected T_c: 2.269
Parameters: 500 sweeps, 200 equilibration, 3 runs per T
============================================================
Temperatures: 100%|██████████| 20/20 [12:29<00:00, 37.45s/it]

============================================================
Validation Results:
============================================================
✓ Phase transition visible near T_c ≈ 2.269
✓ Low T: High magnetization (ordered phase)
✓ High T: Low magnetization (disordered phase)
✓ Energy increases smoothly with T

Note: Some fluctuations in magnetization are expected, especially near T_c
      due to critical slowing down (long correlation times).
      Averaging over 3 runs and 500 sweeps improves smoothness.

✓ 2D implementation validated! Physics is correct.
```

![2D Ising Validation](./output_cell_14.png)

### 3D Validation

The same validation procedure works for 3D, just with a different critical temperature (`$T_c \approx 4.51$`). The physics is the same—we're just checking that our 3D implementation produces the correct phase transition.

```python
def run_fixed_T_3d(ising, T, n_sweeps, n_equil=100, seed=None):
    """Run Metropolis at fixed temperature T (3D)."""
    if seed is not None:
        np.random.seed(seed)
    
    # Equilibration
    for _ in range(n_equil):
        metropolis_sweep_3d(ising, T)
    
    # Production
    energies = []
    magnetizations = []
    for _ in range(n_sweeps):
        metropolis_sweep_3d(ising, T)
        energies.append(ising.get_energy_per_spin())
        magnetizations.append(abs(ising.get_magnetization_per_spin()))
    
    return {
        'energies': np.array(energies),
        'magnetizations': np.array(magnetizations)
    }
```

The 3D validation confirms:
- Phase transition occurs near `$T_c \approx 4.51$`
- Same qualitative behavior as 2D
- Implementation is correct and ready for SA optimization

**Output:**

```
Running 3D fixed-T Metropolis validation...
============================================================
System size: 16×16×16 = 4096 spins
Expected T_c: 4.51
Parameters: 300 sweeps, 150 equilibration, 3 runs per T
============================================================
Temperatures: 100%|██████████| 12/12 [03:47<00:00, 18.93s/it]

============================================================
3D Validation Results:
============================================================
✓ Phase transition visible near T_c ≈ 4.51
✓ Low T: High magnetization (ordered phase)
✓ High T: Low magnetization (disordered phase)
✓ Energy increases with T

Note: Some fluctuations in magnetization are expected, especially near T_c
      due to critical slowing down (long correlation times).
      Averaging over 3 runs and 300 sweeps improves smoothness.

✓ 3D implementation validated! Ready for SA optimization.
```

![3D Ising Validation](./output_cell_16.png)

---

## 6. Simulated Annealing for 3D Ising

Now that we've validated our implementation, let's use **Simulated Annealing** to optimize the 3D Ising model—finding the ground state configuration.

### SA Implementation

We'll use a **geometric cooling schedule**: `$T_{k+1} = \alpha T_k$` where `$\alpha = 0.98$` (slow cooling).

```python
class GeometricSchedule:
    """Geometric cooling schedule: T_{k+1} = alpha * T_k"""
    
    def __init__(self, T0, T_min, alpha=0.95):
        self.T0 = T0
        self.T_min = T_min
        self.alpha = alpha
        self.T = T0
        self.k = 0
    
    def get_temperature(self):
        return self.T
    
    def cool(self):
        self.T = max(self.T * self.alpha, self.T_min)
        self.k += 1
    
    def is_done(self):
        return self.T <= self.T_min


def simulated_annealing_3d(ising, schedule, sweeps_per_T=10, seed=None):
    """Run Simulated Annealing on 3D Ising model.
    
    Args:
        ising: Ising3D instance
        schedule: Cooling schedule (GeometricSchedule)
        sweeps_per_T: Number of sweeps at each temperature
        seed: Random seed
    
    Returns:
        Dictionary with history (energies, temperatures, acceptance_rates)
    """
    if seed is not None:
        np.random.seed(seed)
    
    energies = []
    temperatures = []
    acceptance_rates = []
    
    while not schedule.is_done():
        T = schedule.get_temperature()
        
        # Run sweeps at this temperature
        for _ in range(sweeps_per_T):
            acc_rate = metropolis_sweep_3d(ising, T)
            energies.append(ising.get_energy_per_spin())
            temperatures.append(T)
            acceptance_rates.append(acc_rate)
        
        schedule.cool()
    
    return {
        'energies': np.array(energies),
        'temperatures': np.array(temperatures),
        'acceptance_rates': np.array(acceptance_rates)
    }
```

**Output:**

```
✓ Simulated Annealing implementation ready!
```

### Running SA

```python
L = 12  # System size
J = 1.0
T0 = 6.0  # High starting temperature
T_min = 0.2
alpha = 0.98  # Slow cooling
sweeps_per_T = 10

# Ground state energy per spin
E_ground = -3 * J  # All spins aligned in 3D

# Create system
ising = Ising3D(L, J=J, random=True)
E_init = ising.get_energy_per_spin()

# Run SA
schedule = GeometricSchedule(T0, T_min, alpha=alpha)
results = simulated_annealing_3d(ising, schedule, sweeps_per_T=sweeps_per_T, seed=42)

E_final = ising.get_energy_per_spin()
```

**Output:**

```
Running Simulated Annealing on 3D Ising...
============================================================
System size: 12×12×12 = 1728 spins
Cooling schedule: geometric, α = 0.98
Temperature range: 6.0 → 0.2
Sweeps per temperature: 10
============================================================
Initial energy per spin: -0.0301
Ground state energy per spin: -3.0000
Initial energy gap: 2.9699

Final energy per spin: -3.0000
Final energy gap: 0.0000
Total sweeps: 1690
Energy improvement: 2.9699

============================================================
SA Results:
============================================================
✓ Initial energy: -0.0301
✓ Final energy: -3.0000
✓ Energy gap from ground: 0.0000
✓ Total sweeps: 1690
✓ Final acceptance rate: 0.0000

Key Characteristics:
  • Energy decreases gradually (exploration → exploitation)
  • Acceptance rate decreases with temperature
  • System orders as temperature decreases
  • Final configuration shows large ordered domains
```

![Simulated Annealing Results](./output_cell_19.png)

### Key Characteristics of SA on Ising Model

**Energy Evolution**:
- Starts high (random configuration)
- Decreases gradually as temperature cools
- Approaches ground state energy

**Temperature Schedule**:
- Starts high: Allows exploration (accepts many uphill moves)
- Decreases gradually: Transitions to exploitation
- Ends low: Mostly accepts downhill moves

**Acceptance Rate**:
- High at start: Many moves accepted (exploration)
- Decreases with temperature: More selective (exploitation)
- Low at end: Only good moves accepted

**Configuration Evolution**:
- High T: Disordered, many small domains
- Medium T: Larger domains form
- Low T: Mostly ordered, few domain walls

**Comparison with Fixed-T**: SA finds lower energy than fixed-temperature Metropolis because it allows the system to explore at high temperature, then gradually settle into low-energy states.

---

## 7. Summary and Insights

### Why Ising Model is Excellent for SA

The Ising model serves as an **ideal benchmark** for Simulated Annealing because:

1. **Clear optimization goal**: Find ground state (all spins aligned)
2. **Rich physics**: Phase transitions, critical behavior, well-studied
3. **Visualizable**: Can see domains and ordering in 2D/3D
4. **Scalable**: From small (debugging) to large (realistic physics)
5. **Well-characterized**: Known results for validation

### Implementation Techniques

**Fast Energy Calculation**:
- Local `$\Delta E$`: `$O(1)$` per flip instead of `$O(N)$`
- Only neighbors contribute to energy change
- Critical for large systems

**Periodic Boundary Conditions**:
- Eliminates edge effects
- Provides translation invariance
- Simple implementation with modulo operator

**Code Portability**:
- 2D → 3D: Just change neighbor count
- Same structure, easy to extend

### SA Performance

Simulated Annealing successfully optimizes the 3D Ising model:
- Finds low-energy states efficiently
- Gradual cooling allows escape from local minima
- Final configurations show large ordered domains
- Energy approaches ground state

### Connection to Physics

SA mimics **real thermal annealing**:
- High temperature: System explores (thermal fluctuations)
- Gradual cooling: System orders (domains grow)
- Low temperature: System settles (finds low-energy state)

This physical intuition guides both the algorithm design and our understanding of why it works.

---

## References

- **Onsager, L.** (1944). Crystal statistics. I. A two-dimensional model with an order-disorder transition. *Physical Review*, 65(3-4), 117-149. — Exact solution for 2D Ising model

- **Binder, K., & Heermann, D. W.** (2010). *Monte Carlo Simulation in Statistical Physics: An Introduction*. Springer. — 3D Ising critical temperature `$T_c / J \approx 4.51$`

- **Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P.** (1983). Optimization by simulated annealing. *Science*, 220(4598), 671-680. — Original Simulated Annealing paper

- **Metropolis, N., et al.** (1953). Equation of state calculations by fast computing machines. *The Journal of Chemical Physics*, 21(6), 1087-1092. — Original Metropolis algorithm

