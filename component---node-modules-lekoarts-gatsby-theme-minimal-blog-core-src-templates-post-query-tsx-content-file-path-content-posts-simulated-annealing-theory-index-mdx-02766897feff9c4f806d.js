"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[331],{1173:function(e,t,n){n.d(t,{p:function(){return E},A:function(){return h}});var l=n(6540),a=n(557),r=n(6835),i=n(148),o=n(7715),c=n(7169);var m=e=>{let{post:t}=e;return null};const s=["16px","8px","4px"].map(e=>`rgba(0, 0, 0, 0.1) 0px ${e} ${e} 0px`);var u=e=>{let{data:{post:t},children:n}=e;return(0,a.Y)(i.A,null,(0,a.Y)(r.DZ,{as:"h1",variant:"styles.h1"},t.title),(0,a.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.Y)("time",null,t.date),t.tags&&(0,a.Y)(l.Fragment,null," — ",(0,a.Y)(o.A,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,a.Y)("span",null,t.timeToRead," min read")),(0,a.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:s.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,a.Y)(m,{post:t}))};const E=e=>{var t,n,l;let{data:{post:r}}=e;return(0,a.Y)(c.A,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(t=r.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(l=n.resize)||void 0===l?void 0:l.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function h(e){let{...t}=e;return l.createElement(u,t)}},5426:function(e,t,n){n.r(t),n.d(t,{Head:function(){return o.p},default:function(){return c}});var l=n(6540),a=n(8453);function r(e){const t=Object.assign({h2:"h2",p:"p",strong:"strong",a:"a",hr:"hr",h3:"h3",code:"code",pre:"pre",ul:"ul",li:"li",h4:"h4",blockquote:"blockquote",ol:"ol",em:"em"},(0,a.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h2,null,"Introduction"),"\n",l.createElement(t.p,null,"The idea of ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Simulated_annealing"},"Simulated Annealing"))," (SA) has always fascinated me. The concept behind it (borrowed from physics known for perhaps millennia) is quite simple: ",l.createElement(t.strong,null,"cool slowly and you'll get optimization"),". Unfortunately, I never had the chance to delve into the mathematics or physics behind this algorithm."),"\n",l.createElement(t.p,null,"I want this blog post to give a glimpse of the math and physics that support the intuition. I also prepared a ",l.createElement(t.a,{href:"/simulated-annealing-ising-model-project"},"project post")," that applies the algorithm to the ",l.createElement(t.strong,null,"Ising model"),": a classical but fascinating application."),"\n",l.createElement(t.p,null,"But why does this work? What guarantees do we have? This article explores the ",l.createElement(t.strong,null,"mathematical foundations")," of Simulated Annealing, showing how it emerges from fundamental principles of ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Statistical_mechanics"},"statistical mechanics"))," and how theoretical results guarantee its convergence under certain conditions."),"\n",l.createElement(t.p,null,"We will start by understanding the ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Boltzmann_distribution"},"Boltzmann distribution")),", from which SA was inspired. Then, we will take a deep dive into the ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm"},"Metropolis algorithm")),", which is the core of the SA algorithm. Finally, we will explore the ",l.createElement(t.strong,null,"convergence theorem"),", which guarantees the convergence of the algorithm."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h3,null,"The Boltzmann Distribution"),"\n",l.createElement(t.p,null,"Let's start from the building blocks. At the heart of Simulated Annealing lies the ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Boltzmann_distribution"},"Boltzmann distribution")),", which describes the probability (denoted as ",l.createElement(t.code,null,"$P$"),") of finding a physical system in a state with energy ",l.createElement(t.code,null,"$E$")," at temperature ",l.createElement(t.code,null,"$T$"),":"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P(E) \\propto e^{-E/T}\n")),"\n",l.createElement(t.p,null,"This distribution is fundamental to both statistical mechanics and optimization. What does it tell us?"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"High temperature"),": All states are roughly equally likely → system explores freely"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Low temperature"),": Low-energy states are much more likely → system concentrates near minima"),"\n"),"\n",l.createElement(t.p,null,"But why is this the correct distribution? There are several ways to derive it, each providing different insights. We'll focus on the ",l.createElement(t.strong,null,"Detailed Balance at Equilibrium Approach"),", which directly connects to how the ",l.createElement(t.strong,null,"Metropolis algorithm")," works."),"\n",l.createElement(t.h4,null,"Detailed Balance at Equilibrium Approach (Deep Dive)"),"\n",l.createElement(t.p,null,"At thermal equilibrium, a system must satisfy ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Detailed_balance"},"detailed balance")),". This means that the rate of transitions from state ",l.createElement(t.code,null,"$i$")," to ",l.createElement(t.code,null,"$j$")," equals the rate from ",l.createElement(t.code,null,"$j$")," to ",l.createElement(t.code,null,"$i$"),":"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P(i) \\cdot w(i \\to j) = P(j) \\cdot w(j \\to i)\n")),"\n",l.createElement(t.p,null,"where ",l.createElement(t.code,null,"$w(i \\to j)$")," is the transition rate from state ",l.createElement(t.code,null,"$i$")," to state ",l.createElement(t.code,null,"$j$"),"."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"For thermal systems"),", transition rates typically satisfy ",l.createElement(t.strong,null,"Arrhenius-like behavior"),":"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"w(i \\to j) / w(j \\to i) = e^{-(E_j - E_i)/T}\n")),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Wait, what is Arrhenius-like Behavior?")),"\n",l.createElement(t.p,null,"The ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Arrhenius_equation"},"Arrhenius equation"))," (named after Svante Arrhenius, 1889) describes how reaction/transition rates depend on temperature and energy barriers. It's both ",l.createElement(t.strong,null,"theoretically motivated")," and ",l.createElement(t.strong,null,"experimentally validated"),"."),"\n",l.createElement(t.p,null,"The original Arrhenius equation for chemical reactions is:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"k = A e^{-E_a / (RT)}\n")),"\n",l.createElement(t.p,null,"where ",l.createElement(t.code,null,"$k$")," is the transition rate, ",l.createElement(t.code,null,"$E_a$")," is the activation energy (energy barrier), ",l.createElement(t.code,null,"$R$")," is the gas constant, and ",l.createElement(t.code,null,"$T$")," is temperature."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Physical Interpretation"),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"To transition from state ",l.createElement(t.code,null,"$i$")," to state ",l.createElement(t.code,null,"$j$"),", the system must overcome an energy barrier"),"\n",l.createElement(t.li,null,"The probability of having enough thermal energy to overcome the barrier is proportional to ",l.createElement(t.code,null,"$e^{-\\Delta E/T}$")),"\n",l.createElement(t.li,null,"Higher temperature → more thermal energy → higher transition rate"),"\n",l.createElement(t.li,null,"Larger energy barrier → less likely to overcome → lower transition rate"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"The Result"),": From detailed balance and Arrhenius-like behavior, we get:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P(i) \\cdot w(i \\to j) = P(j) \\cdot w(j \\to i)\n")),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P(i) \\cdot w(i \\to j) = P(j) \\cdot w(i \\to j) \\cdot e^{-(E_j - E_i)/T}\n")),"\n",l.createElement(t.p,null,"Rearranging and simplifying:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\frac{P(i)}{P(j)} = e^{-(E_i - E_j)/T}\n")),"\n",l.createElement(t.p,null,"This immediately leads to the ",l.createElement(t.strong,null,"Boltzmann distribution"),"!"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P(i) \\propto e^{-E_i/T}\n")),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"The Metropolis Algorithm: Foundation of Simulated Annealing"),"\n",l.createElement(t.h3,null,"Why Do We Need It?"),"\n",l.createElement(t.p,null,"Before diving into the mathematics, let's understand the problem the Metropolis algorithm solves."),"\n",l.createElement(t.h4,null,"The Problem: Two Naive Approaches Fail"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Approach 1: Greedy Optimization (Always Go Downhill)")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Rule"),": Only accept moves that decrease energy"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Problem"),": Gets stuck in local minima! Once you're in a valley, you can never escape to find a deeper valley."),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Approach 2: Random Walk (Accept Everything)")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Rule"),": Accept all proposed moves"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Problem"),": Never converges! You just wander around randomly, never settling into low-energy states."),"\n"),"\n",l.createElement(t.h4,null,"The Solution: Probabilistic Acceptance"),"\n",l.createElement(t.p,null,"The Metropolis algorithm solves this by ",l.createElement(t.strong,null,"probabilistically accepting uphill moves"),". The key insight:"),"\n",l.createElement(t.blockquote,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"At high temperature, we explore widely. At low temperature, we exploit what we've found.")),"\n"),"\n",l.createElement(t.p,null,"This balance between exploration and exploitation is what makes SA powerful."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h3,null,"The Metropolis Algorithm: How It Works"),"\n",l.createElement(t.p,null,"Now that we understand the Boltzmann distribution, we can see how the Metropolis algorithm samples from it."),"\n",l.createElement(t.p,null,"The algorithm works by constructing a ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Markov_chain"},"Markov chain")),": a sequence of states where each new state depends only on the current one. Under the right conditions, this chain converges to the Boltzmann distribution (see ",l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Discrete-time_Markov_chain#Stationary_distributions"},"stationary distribution"),"), which is exactly what we want."),"\n",l.createElement(t.p,null,"The Metropolis algorithm has two key components:"),"\n",l.createElement(t.h4,null,"1. Proposal Mechanism: ",l.createElement(t.code,null,"$q(x'|x)$")),"\n",l.createElement(t.p,null,"The ",l.createElement(t.strong,null,"proposal probability")," ",l.createElement(t.code,null,"$q(x'|x)$")," is the probability of proposing state ",l.createElement(t.code,null,"$x'$")," when we're currently in state ",l.createElement(t.code,null,"$x$"),". This is how we explore the state space."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Key Properties:")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Symmetry"),": ",l.createElement(t.code,null,"$q(x'|x) = q(x|x')$")," (equal probability to propose ",l.createElement(t.code,null,"$x'$")," from ",l.createElement(t.code,null,"$x$")," as ",l.createElement(t.code,null,"$x$")," from ",l.createElement(t.code,null,"$x'$"),")"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Normalization"),": ",l.createElement(t.code,null,"$\\sum_{x'} q(x'|x) = 1$")," (must define a valid probability distribution)"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Accessibility"),": For any two states, there should be a path of proposals connecting them (ensures ",l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Ergodicity"},"ergodicity"),")"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Examples of symmetric proposals:")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Gaussian random walk"),": ",l.createElement(t.code,null,"$x' = x + \\mathcal{N}(0, \\sigma^2)$")," → symmetric because Gaussian is symmetric"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Uniform random move"),": ",l.createElement(t.code,null,"$x' = x + \\text{Uniform}(-\\delta, \\delta)$")," → symmetric"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Swap two elements"),": In traveling salesman problem, swapping cities ",l.createElement(t.code,null,"$i$")," and ",l.createElement(t.code,null,"$j$")," → symmetric (swapping back is equally likely)"),"\n"),"\n",l.createElement(t.h4,null,"2. Acceptance Rule: ",l.createElement(t.code,null,"$A(x \\to x') = \\min(1, e^{-\\Delta E/T})$")),"\n",l.createElement(t.p,null,"The ",l.createElement(t.strong,null,"acceptance probability")," determines whether we accept the proposed move:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"A(x \\to x') = \\begin{cases}\n1 & \\text{if } \\Delta E \\leq 0 \\text{ (downhill move)} \\\\\ne^{-\\Delta E/T} & \\text{if } \\Delta E > 0 \\text{ (uphill move)}\n\\end{cases}\n")),"\n",l.createElement(t.p,null,"where ",l.createElement(t.code,null,"$\\Delta E = E(x') - E(x)$")," is the energy change."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Intuition:")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Downhill moves")," (",l.createElement(t.code,null,"$\\Delta E < 0$"),"): Always accept (we want to go to lower energy)"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Uphill moves")," (",l.createElement(t.code,null,"$\\Delta E > 0$"),"): Accept with probability ",l.createElement(t.code,null,"$e^{-\\Delta E/T}$"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Small energy increase → high acceptance probability → allows exploration"),"\n",l.createElement(t.li,null,"Large energy increase → low acceptance probability → avoids bad moves"),"\n",l.createElement(t.li,null,"As ",l.createElement(t.code,null,"$T$")," decreases, uphill moves become less likely → transitions to exploitation"),"\n"),"\n"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Temperature's Role:")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"High ",l.createElement(t.code,null,"$T$")),": ",l.createElement(t.code,null,"$e^{-\\Delta E/T} \\approx 1$")," for most moves → high acceptance → exploration"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Low ",l.createElement(t.code,null,"$T$")),": ",l.createElement(t.code,null,"$e^{-\\Delta E/T} \\approx 0$")," for uphill moves → low acceptance → exploitation"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,l.createElement(t.code,null,"$T \\to 0$")),": Only downhill moves accepted → pure greedy optimization"),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h3,null,"Detailed Balance: The Mathematical Guarantee"),"\n",l.createElement(t.p,null,"For the Metropolis algorithm to converge to the Boltzmann distribution, it must satisfy ",l.createElement(t.strong,null,"detailed balance"),":"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\pi(x) P(x \\to x') = \\pi(x') P(x' \\to x)\n")),"\n",l.createElement(t.p,null,"where:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$\\pi(x) = \\frac{1}{Z} e^{-E(x)/T}$")," is the target distribution (Boltzmann)"),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$P(x \\to x') = q(x'|x) \\cdot A(x \\to x')$")," is the transition probability"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Why Detailed Balance Matters"),": If detailed balance holds, then ",l.createElement(t.code,null,"$\\pi(x)$")," is automatically the stationary distribution. This means the Markov chain will eventually converge to sampling from the Boltzmann distribution, regardless of the starting state."),"\n",l.createElement(t.h4,null,"Proof Sketch"),"\n",l.createElement(t.p,null,"We need to show that the Metropolis algorithm satisfies detailed balance. The proof considers two cases:"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Case 1: Downhill Move (",l.createElement(t.code,null,"$\\Delta E \\leq 0$"),", i.e., ",l.createElement(t.code,null,"$E(x') \\leq E(x)$"),")")),"\n",l.createElement(t.p,null,"When moving to a lower (or equal) energy state:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$A(x \\to x') = 1$")," (always accept downhill moves)"),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$A(x' \\to x) = \\min(1, e^{-(E(x) - E(x'))/T}) = \\min(1, e^{+\\Delta E/T})$")),"\n"),"\n",l.createElement(t.p,null,"Since ",l.createElement(t.code,null,"$\\Delta E \\leq 0$"),", we have ",l.createElement(t.code,null,"$e^{+\\Delta E/T} \\leq 1$"),", so:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$A(x' \\to x) = e^{+\\Delta E/T} = e^{-(E(x') - E(x))/T}$")),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Checking detailed balance:")),"\n",l.createElement(t.p,null,"Left side: ",l.createElement(t.code,null,"$\\pi(x) P(x \\to x') = \\pi(x) \\cdot q(x'|x) \\cdot 1 = \\pi(x) q(x'|x)$")),"\n",l.createElement(t.p,null,"Right side: ",l.createElement(t.code,null,"$\\pi(x') P(x' \\to x) = \\pi(x') \\cdot q(x|x') \\cdot e^{+\\Delta E/T}$")),"\n",l.createElement(t.p,null,"Since ",l.createElement(t.code,null,"$q(x'|x) = q(x|x')$")," (symmetry) and ",l.createElement(t.code,null,"$\\pi(x') = \\pi(x) e^{-\\Delta E/T}$")," (from Boltzmann distribution), we get:"),"\n",l.createElement(t.p,null,"Right side: ",l.createElement(t.code,null,"$\\pi(x) e^{-\\Delta E/T} \\cdot q(x'|x) \\cdot e^{+\\Delta E/T} = \\pi(x) q(x'|x)$")),"\n",l.createElement(t.p,null,"Therefore: ",l.createElement(t.code,null,"$\\pi(x) P(x \\to x') = \\pi(x') P(x' \\to x)$")," ✔"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Case 2: Uphill Move (",l.createElement(t.code,null,"$\\Delta E > 0$"),", i.e., ",l.createElement(t.code,null,"$E(x') > E(x)$"),")")),"\n",l.createElement(t.p,null,"When moving to a higher energy state:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$A(x \\to x') = e^{-\\Delta E/T}$")),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"$A(x' \\to x) = 1$")," (moving back is downhill)"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Checking detailed balance:")),"\n",l.createElement(t.p,null,"Left side: ",l.createElement(t.code,null,"$\\pi(x) P(x \\to x') = \\pi(x) \\cdot q(x'|x) \\cdot e^{-\\Delta E/T}$")),"\n",l.createElement(t.p,null,"Right side: ",l.createElement(t.code,null,"$\\pi(x') P(x' \\to x) = \\pi(x') \\cdot q(x|x') \\cdot 1 = \\pi(x') q(x'|x)$")),"\n",l.createElement(t.p,null,"Since ",l.createElement(t.code,null,"$\\pi(x') = \\pi(x) e^{-\\Delta E/T}$")," and ",l.createElement(t.code,null,"$q(x'|x) = q(x|x')$"),", we get:"),"\n",l.createElement(t.p,null,"Right side: ",l.createElement(t.code,null,"$\\pi(x) e^{-\\Delta E/T} \\cdot q(x'|x) = \\pi(x) q(x'|x) e^{-\\Delta E/T}$")),"\n",l.createElement(t.p,null,"Therefore: ",l.createElement(t.code,null,"$\\pi(x) P(x \\to x') = \\pi(x') P(x' \\to x)$")," ✔"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Conclusion"),": The Metropolis algorithm satisfies detailed balance for both downhill and uphill moves, ensuring convergence to the Boltzmann distribution!"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"Simulated Annealing: From Fixed Temperature to Optimization"),"\n",l.createElement(t.h3,null,"The Key Idea"),"\n",l.createElement(t.p,null,"The Metropolis algorithm at ",l.createElement(t.strong,null,"fixed temperature")," samples from the Boltzmann distribution at that temperature. This is useful for understanding equilibrium properties in physics, but not for optimization."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Simulated Annealing")," makes a crucial modification: ",l.createElement(t.strong,null,"decrease the temperature over time"),". This transforms the algorithm from a sampling method into an optimization method."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"SA as Non-Stationary Markov Chain"),": Since the temperature changes with iteration ",l.createElement(t.code,null,"$k$"),", the acceptance probabilities change over time. This makes SA a ",l.createElement(t.strong,null,"time-inhomogeneous")," (non-stationary) Markov process, unlike fixed-temperature Metropolis which is stationary."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h3,null,"The Convergence Theorem"),"\n",l.createElement(t.p,null,"There's a beautiful theoretical result about Simulated Annealing, first rigorously proved by ",l.createElement(t.strong,null,"Hajek (1988)"),":"),"\n",l.createElement(t.blockquote,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"If we cool infinitely slowly")," (i.e., ",l.createElement(t.code,null,"$T(k) \\to 0$")," as ",l.createElement(t.code,null,"$k \\to \\infty$")," in a specific way), ",l.createElement(t.strong,null,"SA is guaranteed to find the global minimum with probability 1.")),"\n"),"\n",l.createElement(t.h4,null,"Formal Statement (Hajek's Theorem, 1988)"),"\n",l.createElement(t.p,null,"Under certain conditions on the energy landscape (the function that we want to optimize) and proposal mechanism, if the temperature schedule satisfies:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"T(k) \\geq \\frac{C}{\\log(k+1)}\n")),"\n",l.createElement(t.p,null,"for a sufficiently large constant ",l.createElement(t.code,null,"$C$")," (depending on the energy landscape), then:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\lim_{k \\to \\infty} P(\\text{SA finds global minimum}) = 1\n")),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Key conditions"),":"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Irreducibility"),": Every state is reachable from every other state (via a sequence of proposals)"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Aperiodicity"),": The Markov chain doesn't get stuck in cycles"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Connectivity"),': The energy landscape has a "path" from any state to the global minimum'),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Bounded energy differences"),": Energy changes ",l.createElement(t.code,null,"$\\Delta E$")," are bounded (or have bounded variance)"),"\n"),"\n",l.createElement(t.p,null,"The constant ",l.createElement(t.code,null,"$C$")," must satisfy ",l.createElement(t.code,null,"$C \\geq \\Delta E_{\\max}$"),", where ",l.createElement(t.code,null,"$\\Delta E_{\\max}$")," is the ",l.createElement(t.strong,null,"largest energy barrier")," in the landscape."),"\n",l.createElement(t.h4,null,"Why Does This Work? (Proof Sketch)"),"\n",l.createElement(t.p,null,"The proof relies on understanding ",l.createElement(t.strong,null,"mixing times")," and ",l.createElement(t.strong,null,"escape probabilities"),". Here's the intuitive argument:"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"The Core Idea: Escape from Local Minima")),"\n",l.createElement(t.p,null,"The fundamental challenge in optimization is ",l.createElement(t.strong,null,"escaping from local minima"),". At temperature ",l.createElement(t.code,null,"$T$"),", the probability of escaping a local minimum with energy barrier ",l.createElement(t.code,null,"$\\Delta E$")," is approximately:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"P_{\\text{escape}}(T) \\propto e^{-\\Delta E/T}\n")),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Key insight"),": As ",l.createElement(t.code,null,"$T \\to 0$"),", this probability goes to zero ",l.createElement(t.strong,null,"exponentially fast"),". If we cool too fast, we'll get trapped before we can escape!"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"The Mixing Time Argument")),"\n",l.createElement(t.p,null,"At each temperature ",l.createElement(t.code,null,"$T$"),", the system needs time to ",l.createElement(t.strong,null,"reach equilibrium")," (the Boltzmann distribution). This time is called the ",l.createElement(t.strong,null,"mixing time")," ",l.createElement(t.code,null,"$\\tau_{\\text{mix}}(T)$"),"."),"\n",l.createElement(t.p,null,"For many systems, the mixing time scales as:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\tau_{\\text{mix}}(T) \\propto e^{\\Delta E_{\\max}/T}\n")),"\n",l.createElement(t.p,null,"where ",l.createElement(t.code,null,"$\\Delta E_{\\max}$")," is the ",l.createElement(t.strong,null,"largest energy barrier")," in the landscape."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Why exponential?")," To escape the highest barrier, we need to wait long enough for a rare thermal fluctuation. The probability of such a fluctuation is ",l.createElement(t.code,null,"$e^{-\\Delta E_{\\max}/T}$"),", so we need ",l.createElement(t.code,null,"$\\sim e^{\\Delta E_{\\max}/T}$")," attempts on average."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"How the Logarithmic Schedule Ensures Equilibrium")),"\n",l.createElement(t.p,null,"For the logarithmic schedule ",l.createElement(t.code,null,"$T(k) = C/\\log(k+1)$"),", we want to know the number of iterations ",l.createElement(t.code,null,"$\\Delta k$")," spent in a small temperature range around ",l.createElement(t.code,null,"$T$"),". Using the linear approximation (since ",l.createElement(t.code,null,"$\\Delta T$")," is small), we get:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\Delta k \\approx \\left|\\frac{dk}{dT}\\right| \\cdot \\Delta T\n")),"\n",l.createElement(t.p,null,"where ",l.createElement(t.code,null,"$\\frac{dk}{dT} = -\\frac{C}{T^2} e^{C/T}$"),". This gives us:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\Delta k \\propto \\frac{C}{T^2} e^{C/T}\n")),"\n",l.createElement(t.p,null,"For small ",l.createElement(t.code,null,"$T$")," (low temperatures), the exponential term ",l.createElement(t.code,null,"$e^{C/T}$")," ",l.createElement(t.strong,null,"dominates"),", so:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"\\Delta k \\propto e^{C/T}\n")),"\n",l.createElement(t.p,null,"But remember, we need ",l.createElement(t.code,null,"$\\tau_{\\text{mix}}(T) \\propto e^{\\Delta E_{\\max}/T}$")," iterations."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"How does logarithmic schedule work?")," The key is that we need to choose ",l.createElement(t.code,null,"$C$")," ",l.createElement(t.strong,null,"large enough"),":"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"C \\geq \\Delta E_{\\max}\n")),"\n",l.createElement(t.p,null,"When this holds, the logarithmic schedule ensures we spend ",l.createElement(t.strong,null,"exponentially many iterations")," at each temperature level, which is exactly what we need to overcome the exponential mixing time!"),"\n",l.createElement(t.h4,null,"Physical Interpretation"),"\n",l.createElement(t.p,null,"This result beautifully mirrors ",l.createElement(t.strong,null,l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Annealing_(materials_science)"},"physical annealing")),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"In real annealing, you cool metal slowly to avoid defects (trapped states)"),"\n",l.createElement(t.li,null,"The cooling rate must be slower than the ",l.createElement(t.strong,null,"relaxation time")," of the material"),"\n",l.createElement(t.li,null,'SA\'s logarithmic schedule ensures we cool slower than the "relaxation time" (mixing time) of the optimization problem'),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"The Theory vs. Practice trade-off"),":"),"\n",l.createElement(t.p,null,"Logarithmic schedules are ",l.createElement(t.strong,null,"too slow")," for most applications. The requirement ",l.createElement(t.code,null,"$T(k) \\geq C/\\log(k+1)$")," means:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"To reach ",l.createElement(t.code,null,"$T = 0.1$")," from ",l.createElement(t.code,null,"$T_0 = 10$")," with ",l.createElement(t.code,null,"$C = 10$"),", we need ",l.createElement(t.code,null,"$k \\approx e^{100} \\approx 10^{43}$")," iterations!"),"\n",l.createElement(t.li,null,"This is computationally infeasible"),"\n"),"\n",l.createElement(t.p,null,"In practice, we use ",l.createElement(t.strong,null,"faster schedules")," that sacrifice theoretical guarantees for computational efficiency."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h3,null,"Practical Cooling Schedules"),"\n",l.createElement(t.p,null,"Since logarithmic schedules are impractical, several ",l.createElement(t.strong,null,"finite-time schedules")," are commonly used:"),"\n",l.createElement(t.h4,null,"1. Geometric Schedule: ",l.createElement(t.code,null,"$T_{k+1} = \\alpha T_k$")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Pros"),": Simple, widely used, good performance in practice"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Cons"),": No theoretical guarantee"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Typical values"),": ",l.createElement(t.code,null,"$\\alpha = 0.90$")," to ",l.createElement(t.code,null,"$0.99$")," (higher = slower cooling)"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Use"),": Most common choice for practical applications"),"\n"),"\n",l.createElement(t.h4,null,"2. Adaptive Schedule: Adjusts based on acceptance rate"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Pros"),": Adapts to problem characteristics, can be more efficient"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Cons"),": More complex, requires tuning"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Idea"),": Maintain target acceptance rate (e.g., 40%) by adjusting cooling rate"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Use"),": When problem characteristics are unknown or vary"),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Note"),": The logarithmic schedule (discussed in detail above) provides theoretical guarantees but is computationally infeasible for practical applications."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"Conclusion"),"\n",l.createElement(t.p,null,"Simulated Annealing bridges the gap between physics and optimization, showing how principles from statistical mechanics can solve hard optimization problems."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Key Insights"),":"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"The Metropolis Algorithm"),": Probabilistic acceptance based on the Boltzmann distribution allows balancing exploration and exploitation"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Detailed Balance"),": The mathematical guarantee that ensures convergence to the target distribution"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"The Convergence Theorem"),": Infinitely slow cooling guarantees finding the global minimum, though practical schedules sacrifice this guarantee for efficiency"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Physical Intuition"),": SA mimics real annealing, where slow cooling allows systems to find low-energy configurations"),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"References"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Metropolis, N., Rosenbluth, A. W., Rosenbluth, M. N., Teller, A. H., & Teller, E.")," (1953). Equation of state calculations by fast computing machines. ",l.createElement(t.em,null,"The Journal of Chemical Physics"),", 21(6), 1087-1092. — Original Metropolis algorithm"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P.")," (1983). Optimization by simulated annealing. ",l.createElement(t.em,null,"Science"),", 220(4598), 671-680. — Original Simulated Annealing paper"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Hajek, B.")," (1988). Cooling schedules for optimal annealing. ",l.createElement(t.em,null,"Mathematics of Operations Research"),", 13(2), 311-329. — Convergence theorem"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Arrhenius, S.")," (1889). Über die Reaktionsgeschwindigkeit bei der Inversion von Rohrzucker durch Säuren. ",l.createElement(t.em,null,"Zeitschrift für Physikalische Chemie"),", 4, 226-248. — Original Arrhenius equation"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Chandler, D.")," (1987). ",l.createElement(t.em,null,"Introduction to Modern Statistical Mechanics"),". Oxford University Press. — Statistical mechanics background"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Binder, K., & Heermann, D. W.")," (2010). ",l.createElement(t.em,null,"Monte Carlo Simulation in Statistical Physics: An Introduction"),". Springer. — Monte Carlo methods"),"\n"),"\n"))}var i=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)},o=n(1173);function c(e){return l.createElement(o.A,e,l.createElement(i,e))}o.A},7169:function(e,t,n){var l=n(6540),a=n(4794),r=n(7533);t.A=e=>{let{title:t="",description:n="",pathname:i="",image:o="",children:c=null,canonicalUrl:m=""}=e;const s=(0,r.A)(),{siteTitle:u,siteTitleAlt:E,siteUrl:h,siteDescription:p,siteImage:d,author:g,siteLanguage:$}=s,x={title:t?`${t} | ${u}`:E,description:n||p,url:`${h}${i||""}`,image:`${h}${o||d}`};return l.createElement(l.Fragment,null,l.createElement("html",{lang:$}),l.createElement("title",null,x.title),l.createElement("meta",{name:"description",content:x.description}),l.createElement("meta",{name:"image",content:x.image}),l.createElement("meta",{property:"og:title",content:x.title}),l.createElement("meta",{property:"og:url",content:x.url}),l.createElement("meta",{property:"og:description",content:x.description}),l.createElement("meta",{property:"og:image",content:x.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:x.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:x.title}),l.createElement("meta",{name:"twitter:url",content:x.url}),l.createElement("meta",{name:"twitter:description",content:x.description}),l.createElement("meta",{name:"twitter:image",content:x.image}),l.createElement("meta",{name:"twitter:image:alt",content:x.description}),l.createElement("meta",{name:"twitter:creator",content:g}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),m?l.createElement("link",{rel:"canonical",href:m}):null,c)}},7715:function(e,t,n){var l=n(557),a=n(6540),r=n(4794),i=n(3601),o=n(2174);t.A=e=>{let{tags:t}=e;const{tagsPath:n,basePath:c}=(0,i.A)();return(0,l.Y)(a.Fragment,null,t.map((e,t)=>(0,l.Y)(a.Fragment,{key:e.slug},!!t&&", ",(0,l.Y)(r.Link,{sx:e=>{var t;return{...null===(t=e.styles)||void 0===t?void 0:t.a}},to:(0,o.A)(`/${c}/${n}/${e.slug}`)},e.name))))}}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-simulated-annealing-theory-index-mdx-02766897feff9c4f806d.js.map