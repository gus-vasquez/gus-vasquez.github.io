"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[346],{1173:function(e,n,t){t.d(n,{p:function(){return p},A:function(){return g}});var l=t(6540),a=t(557),r=t(6835),i=t(148),s=t(7715),o=t(7169);var c=e=>{let{post:n}=e;return null};const m=["16px","8px","4px"].map(e=>`rgba(0, 0, 0, 0.1) 0px ${e} ${e} 0px`);var u=e=>{let{data:{post:n},children:t}=e;return(0,a.Y)(i.A,null,(0,a.Y)(r.DZ,{as:"h1",variant:"styles.h1"},n.title),(0,a.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.Y)("time",null,n.date),n.tags&&(0,a.Y)(l.Fragment,null," — ",(0,a.Y)(s.A,{tags:n.tags})),n.timeToRead&&" — ",n.timeToRead&&(0,a.Y)("span",null,n.timeToRead," min read")),(0,a.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:m.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},t),(0,a.Y)(c,{post:n}))};const p=e=>{var n,t,l;let{data:{post:r}}=e;return(0,a.Y)(o.A,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(n=r.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(l=t.resize)||void 0===l?void 0:l.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function g(e){let{...n}=e;return l.createElement(u,n)}},7169:function(e,n,t){var l=t(6540),a=t(4794),r=t(7533);n.A=e=>{let{title:n="",description:t="",pathname:i="",image:s="",children:o=null,canonicalUrl:c=""}=e;const m=(0,r.A)(),{siteTitle:u,siteTitleAlt:p,siteUrl:g,siteDescription:d,siteImage:E,author:h,siteLanguage:f}=m,y={title:n?`${n} | ${u}`:p,description:t||d,url:`${g}${i||""}`,image:`${g}${s||E}`};return l.createElement(l.Fragment,null,l.createElement("html",{lang:f}),l.createElement("title",null,y.title),l.createElement("meta",{name:"description",content:y.description}),l.createElement("meta",{name:"image",content:y.image}),l.createElement("meta",{property:"og:title",content:y.title}),l.createElement("meta",{property:"og:url",content:y.url}),l.createElement("meta",{property:"og:description",content:y.description}),l.createElement("meta",{property:"og:image",content:y.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:y.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:y.title}),l.createElement("meta",{name:"twitter:url",content:y.url}),l.createElement("meta",{name:"twitter:description",content:y.description}),l.createElement("meta",{name:"twitter:image",content:y.image}),l.createElement("meta",{name:"twitter:image:alt",content:y.description}),l.createElement("meta",{name:"twitter:creator",content:h}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),c?l.createElement("link",{rel:"canonical",href:c}):null,o)}},7715:function(e,n,t){var l=t(557),a=t(6540),r=t(4794),i=t(3601),s=t(2174);n.A=e=>{let{tags:n}=e;const{tagsPath:t,basePath:o}=(0,i.A)();return(0,l.Y)(a.Fragment,null,n.map((e,n)=>(0,l.Y)(a.Fragment,{key:e.slug},!!n&&", ",(0,l.Y)(r.Link,{sx:e=>{var n;return{...null===(n=e.styles)||void 0===n?void 0:n.a}},to:(0,s.A)(`/${o}/${t}/${e.slug}`)},e.name))))}},9874:function(e,n,t){t.r(n),t.d(n,{Head:function(){return s.p},default:function(){return o}});var l=t(6540),a=t(8453);function r(e){const n=Object.assign({blockquote:"blockquote",p:"p",strong:"strong",a:"a",h3:"h3",ul:"ul",li:"li",code:"code",pre:"pre",hr:"hr",h2:"h2",ol:"ol",span:"span",em:"em"},(0,a.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Note:")," For the theoretical foundations of Simulated Annealing, see the companion blog post: ",l.createElement(n.a,{href:"/simulated-annealing-theory"},"Simulated Annealing: From Physics to Optimization")),"\n"),"\n",l.createElement(n.h3,null,"Setup"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Python 3.11+, ",l.createElement(n.code,null,"numpy"),", ",l.createElement(n.code,null,"matplotlib"),", ",l.createElement(n.code,null,"numba"),", ",l.createElement(n.code,null,"imageio"),", ",l.createElement(n.code,null,"tqdm"),", ",l.createElement(n.code,null,"scipy"),"."),"\n",l.createElement(n.li,null,"Reproducibility: random seed + consistent parameters."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},"# Import libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nfrom tqdm import tqdm\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Set style\nplt.style.use('default')\nplt.rcParams['figure.figsize'] = (12, 8)\nplt.rcParams['font.size'] = 10\n\nprint(\"✓ Libraries imported!\")\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"✓ Libraries imported!\n")),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"Project Overview"),"\n",l.createElement(n.p,null,"This project demonstrates ",l.createElement(n.strong,null,"Simulated Annealing")," applied to the ",l.createElement(n.strong,null,"Ising Model"),"—a classic problem in statistical physics that serves as an excellent benchmark for optimization algorithms."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"What You'll Learn:")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Why the Ising model is perfect for demonstrating SA"),"\n",l.createElement(n.li,null,"Onsager's exact solution for 2D Ising (one of the most beautiful results in physics)"),"\n",l.createElement(n.li,null,"Implementation techniques: fast energy calculation, periodic boundary conditions"),"\n",l.createElement(n.li,null,"How SA successfully optimizes the 3D Ising model"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Structure:")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Introduction: Why Ising Model for SA?"),"\n",l.createElement(n.li,null,"The Ising Model: Quick Review"),"\n",l.createElement(n.li,null,"The Critical Temperature: Onsager's Exact Solution (2D)"),"\n",l.createElement(n.li,null,"Implementation Details"),"\n",l.createElement(n.li,null,"Fixed-Temperature Metropolis Validation"),"\n",l.createElement(n.li,null,"Simulated Annealing for 3D Ising"),"\n",l.createElement(n.li,null,"Summary and Insights"),"\n"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"1. Introduction: Why Ising Model for SA?"),"\n",l.createElement(n.p,null,"The ",l.createElement(n.strong,null,"Ising model")," is an ideal testbed for Simulated Annealing. Here's why:"),"\n",l.createElement(n.h3,null,"Clear Optimization Goal"),"\n",l.createElement(n.p,null,"The Ising model has a ",l.createElement(n.strong,null,"well-defined optimization problem"),": find the configuration of spins that minimizes the energy. The ground state (all spins aligned) is known, making it easy to evaluate how well SA performs."),"\n",l.createElement(n.h3,null,"Rich Physics"),"\n",l.createElement(n.p,null,"The Ising model exhibits:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Phase transitions"),": Sharp change in behavior at critical temperature ",l.createElement(n.code,null,"$T_c$")),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Critical behavior"),": Power-law scaling, universality"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Order-disorder transition"),": From ordered (low T) to disordered (high T) phases"),"\n"),"\n",l.createElement(n.p,null,"This rich physics makes it interesting beyond just optimization."),"\n",l.createElement(n.h3,null,"Visualizable"),"\n",l.createElement(n.p,null,"In 2D and 3D, we can ",l.createElement(n.strong,null,"visualize")," spin configurations:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"See domains form and grow"),"\n",l.createElement(n.li,null,"Observe ordering as temperature decreases"),"\n",l.createElement(n.li,null,"Understand how SA explores the energy landscape"),"\n"),"\n",l.createElement(n.h3,null,"Well-Studied"),"\n",l.createElement(n.p,null,"The Ising model is one of the most studied models in statistical physics:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"2D"),": Exact solution by Onsager (1944) — ",l.createElement(n.code,null,"$T_c / J = 2/\\ln(1+\\sqrt{2}) \\approx 2.269$")),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"3D"),": Well-characterized numerically — ",l.createElement(n.code,null,"$T_c / J \\approx 4.51$")),"\n",l.createElement(n.li,null,"Extensive literature for validation"),"\n"),"\n",l.createElement(n.h3,null,"Scalable"),"\n",l.createElement(n.p,null,"We can study systems from small (for debugging) to large (for realistic physics):"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Small (",l.createElement(n.code,null,"$L=8$"),"): Fast, easy to visualize"),"\n",l.createElement(n.li,null,"Medium (",l.createElement(n.code,null,"$L=16$"),"): Good balance"),"\n",l.createElement(n.li,null,"Large (",l.createElement(n.code,null,"$L=32+$"),"): Realistic physics, challenging optimization"),"\n"),"\n",l.createElement(n.h3,null,"Perfect for SA"),"\n",l.createElement(n.p,null,"The Ising model has:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Many local minima"),": Different spin configurations with varying energies"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Energy barriers"),": Need thermal fluctuations to escape local minima"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Clear ground state"),": All spins aligned (easy to verify)"),"\n"),"\n",l.createElement(n.p,null,"This makes it an ",l.createElement(n.strong,null,"excellent benchmark")," for SA and other optimization algorithms."),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"2. The Ising Model: Quick Review"),"\n",l.createElement(n.h3,null,"The Hamiltonian (Energy Function)"),"\n",l.createElement(n.p,null,"For a system of spins ",l.createElement(n.code,null,"$\\mathbf{s} = \\{s_1, s_2, \\ldots, s_N\\}$")," where each ",l.createElement(n.code,null,"$s_i \\in \\{-1, +1\\}$"),", the ",l.createElement(n.strong,null,"Ising Hamiltonian")," is:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"E(\\mathbf{s}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Key components:")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,l.createElement(n.code,null,"$J > 0$")),": Coupling constant (ferromagnetic: spins want to align)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,l.createElement(n.code,null,"$\\langle i,j \\rangle$")),": Sum over nearest neighbors only","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"2D: 4 neighbors per spin"),"\n",l.createElement(n.li,null,"3D: 6 neighbors per spin"),"\n"),"\n"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,l.createElement(n.code,null,"$s_i s_j$")),": Interaction term","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Aligned (",l.createElement(n.code,null,"$s_i = s_j$"),"): contributes ",l.createElement(n.code,null,"$-J$")," (lower energy)"),"\n",l.createElement(n.li,null,"Anti-aligned (",l.createElement(n.code,null,"$s_i \\neq s_j$"),"): contributes ",l.createElement(n.code,null,"$+J$")," (higher energy)"),"\n"),"\n"),"\n"),"\n",l.createElement(n.h3,null,"Ground State"),"\n",l.createElement(n.p,null,"The ",l.createElement(n.strong,null,"ground state")," (minimum energy) is when ",l.createElement(n.strong,null,"all spins are aligned"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"2D: ",l.createElement(n.code,null,"$E_0 = -2JL^2$")," (per spin: ",l.createElement(n.code,null,"$-2J$"),")"),"\n",l.createElement(n.li,null,"3D: ",l.createElement(n.code,null,"$E_0 = -3JL^3$")," (per spin: ",l.createElement(n.code,null,"$-3J$"),")"),"\n"),"\n",l.createElement(n.h3,null,"Observables"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Energy"),": ",l.createElement(n.code,null,"$E = -J \\sum_{\\langle i,j \\rangle} s_i s_j$")),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Magnetization"),": ",l.createElement(n.code,null,"$M = \\sum_i s_i$")," (sum of all spins)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Energy per spin"),": ",l.createElement(n.code,null,"$e = E / N$")),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Magnetization per spin"),": ",l.createElement(n.code,null,"$m = M / N$")),"\n"),"\n",l.createElement(n.h3,null,"Phase Transitions"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Below ",l.createElement(n.code,null,"$T_c$")),": Ordered phase (high magnetization, low energy)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"At ",l.createElement(n.code,null,"$T_c$")),": Critical point (phase transition)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Above ",l.createElement(n.code,null,"$T_c$")),": Disordered phase (low magnetization, higher energy)"),"\n"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"3. The Critical Temperature: Onsager's Exact Solution (2D)"),"\n",l.createElement(n.h3,null,"The Famous Result"),"\n",l.createElement(n.p,null,"The critical temperature for the 2D Ising model is an ",l.createElement(n.strong,null,"exact result")," derived by Lars Onsager in 1944:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"T_c = \\frac{2J}{\\ln(1 + \\sqrt{2})} \\approx 2.269 J\n")),"\n",l.createElement(n.p,null,"This is remarkable because:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"It's ",l.createElement(n.strong,null,"exact")," (no approximations)"),"\n",l.createElement(n.li,null,"It's one of ",l.createElement(n.strong,null,"very few")," exact solutions in statistical physics"),"\n",l.createElement(n.li,null,"It was a major breakthrough in theoretical physics"),"\n"),"\n",l.createElement(n.h3,null,"Why This is Special"),"\n",l.createElement(n.p,null,"Most statistical physics models require numerical methods or approximations. The 2D Ising model is special because:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"It has an ",l.createElement(n.strong,null,"exact analytical solution")),"\n",l.createElement(n.li,null,"The solution reveals deep mathematical structure (Onsager algebra)"),"\n",l.createElement(n.li,null,"It provides a benchmark for numerical methods"),"\n"),"\n",l.createElement(n.h3,null,"Sketch of Onsager's Solution"),"\n",l.createElement(n.p,null,"Onsager's solution uses the ",l.createElement(n.strong,null,"transfer matrix method"),", which reduces the 2D problem to a 1D eigenvalue problem. Here's the key idea:"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Challenge"),": Computing the partition function ",l.createElement(n.code,null,"$Z = \\sum_{\\{\\mathbf{s}\\}} e^{-E(\\mathbf{s})/T}$")," requires summing over ",l.createElement(n.code,null,"$2^{L^2}$")," configurations—impossible for large ",l.createElement(n.code,null,"$L$"),"!"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Breakthrough"),": Instead of summing over all configurations at once, build the partition function ",l.createElement(n.strong,null,"row by row")," using a transfer matrix."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Transfer Matrix"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"For an ",l.createElement(n.code,null,"$L \\times L$")," lattice, the transfer matrix ",l.createElement(n.code,null,"$T$")," is ",l.createElement(n.code,null,"$2^L \\times 2^L$")),"\n",l.createElement(n.li,null,"Each row/column corresponds to one of the ",l.createElement(n.code,null,"$2^L$")," possible row configurations"),"\n",l.createElement(n.li,null,"Matrix element ",l.createElement(n.code,null,"$T[i,j]$")," encodes the Boltzmann weight for transitioning from row configuration ",l.createElement(n.code,null,"$i$")," to row configuration ",l.createElement(n.code,null,"$j$")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Magic"),": The partition function becomes:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Z = \\text{Tr}(T^N) = \\sum_{i=1}^{2^L} \\lambda_i^N\n")),"\n",l.createElement(n.p,null,"where ",l.createElement(n.code,null,"$N$")," is the number of rows and ",l.createElement(n.code,null,"$\\lambda_i$")," are eigenvalues of ",l.createElement(n.code,null,"$T$"),"."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Complexity Reduction"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Direct sum: ",l.createElement(n.code,null,"$2^{L^2}$")," terms (exponential in area)"),"\n",l.createElement(n.li,null,"Transfer matrix: ",l.createElement(n.code,null,"$2^L \\times 2^L$")," matrix (exponential in width, not area!)"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Finding ",l.createElement(n.code,null,"$T_c$")),": The critical temperature occurs when the largest eigenvalue becomes degenerate (two eigenvalues become equal). This requires solving the ",l.createElement(n.strong,null,"Onsager algebra"),"—a non-commutative Lie algebra that describes the symmetries of the 2D Ising model."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Why Onsager Algebra?")," The transfer matrix can be written as ",l.createElement(n.code,null,"$T = V_1 V_2$")," where ",l.createElement(n.code,null,"$V_1$")," and ",l.createElement(n.code,null,"$V_2$")," don't commute. The Onsager algebra provides the mathematical structure needed to diagonalize this and find the eigenvalues exactly."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Result"),": After solving the Onsager algebra, the critical temperature emerges as:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"T_c = \\frac{2J}{\\ln(1 + \\sqrt{2})}\n")),"\n",l.createElement(n.p,null,"This is why physicists learn group theory and Lie algebras—they reveal hidden symmetries that make exact solutions possible!"),"\n",l.createElement(n.p,null,"Let's visualize the transfer matrix for a small system (L=2) to understand how it works:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'# Visual Example: Transfer Matrix for L=2\n\ndef build_transfer_matrix_2x2(J, T):\n    """Build transfer matrix for 2x2 system (L=2 columns).\n    \n    For L=2, there are 2^2 = 4 possible row configurations:\n    (+1,+1), (+1,-1), (-1,+1), (-1,-1)\n    \n    The transfer matrix is 4x4.\n    """\n    beta = 1.0 / T\n    \n    # All possible row configurations (L=2)\n    configs = [\n        np.array([+1, +1]),  # 0: (+,+)\n        np.array([+1, -1]),  # 1: (+,-)\n        np.array([-1, +1]),  # 2: (-,+)\n        np.array([-1, -1])   # 3: (-,-)\n    ]\n    \n    T_matrix = np.zeros((4, 4))\n    \n    for i, row1 in enumerate(configs):\n        for j, row2 in enumerate(configs):\n            # Energy from horizontal bonds in row1\n            E_horizontal = -J * (row1[0] * row1[1])\n            \n            # Energy from vertical bonds between row1 and row2\n            E_vertical = -J * (row1[0] * row2[0] + row1[1] * row2[1])\n            \n            # Total energy contribution\n            E_total = E_horizontal + E_vertical\n            \n            # Transfer matrix element\n            T_matrix[i, j] = np.exp(-beta * E_total)\n    \n    return T_matrix, configs\n\n# Build transfer matrix at T_c\nJ = 1.0\nT_c = 2.269\nT_mat, configs = build_transfer_matrix_2x2(J, T_c)\neigenvalues = np.real(np.linalg.eigvals(T_mat))\nlambda_max = np.max(eigenvalues)\n\nprint("Transfer Matrix for L=2 at T = T_c = 2.269")\nprint("=" * 60)\nprint("\\nRow configurations:")\nprint("  0: (+1, +1)")\nprint("  1: (+1, -1)")\nprint("  2: (-1, +1)")\nprint("  3: (-1, -1)")\nprint(f"\\nLargest eigenvalue: λ_max = {lambda_max:.6f}")\nprint("\\nTransfer matrix T:")\nprint(T_mat)\n\n# Visualize\nfig, ax = plt.subplots(1, 1, figsize=(8, 7))\nim = ax.imshow(T_mat, cmap=\'viridis\', aspect=\'auto\')\nax.set_title(f\'Transfer Matrix at T = T_c = 2.269\\n(4×4 matrix for L=2)\', fontsize=12)\nax.set_xlabel(\'Column: Row configuration j\', fontsize=11)\nax.set_ylabel(\'Row: Row configuration i\', fontsize=11)\nax.set_xticks(range(4))\nax.set_yticks(range(4))\nax.set_xticklabels([\'(+,+)\', \'(+,-)\', \'(-,+)\', \'(-,-)\'], fontsize=10)\nax.set_yticklabels([\'(+,+)\', \'(+,-)\', \'(-,+)\', \'(-,-)\'], fontsize=10)\nplt.colorbar(im, ax=ax, label=\'Matrix element value\')\nplt.tight_layout()\nplt.show()\n\nprint("\\n" + "=" * 60)\nprint("Key Insight:")\nprint("=" * 60)\nprint("✓ Each matrix element T[i,j] is a single number (Boltzmann weight)")\nprint("✓ T[i,j] encodes transition from row config i to row config j")\nprint("✓ The 4×4 matrix organizes the 2^4 = 16 possible transitions")\nprint("✓ For larger L, matrix is 2^L × 2^L (still much smaller than 2^(L^2)!)")\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Transfer Matrix for L=2 at T = T_c = 2.269\n============================================================\n\nRow configurations:\n  0: (+1, +1)\n  1: (+1, -1)\n  2: (-1, +1)\n  3: (-1, -1)\n\nLargest eigenvalue: λ_max = 5.486263\n\nTransfer matrix T:\n[[3.75154725 1.5538299  1.5538299  0.64357109]\n [0.64357109 1.5538299  0.26655669 0.64357109]\n [0.64357109 0.26655669 1.5538299  0.64357109]\n [0.64357109 1.5538299  1.5538299  3.75154725]]\n\n============================================================\nKey Insight:\n============================================================\n✓ Each matrix element T[i,j] is a single number (Boltzmann weight)\n✓ T[i,j] encodes transition from row config i to row config j\n✓ The 4×4 matrix organizes the 2^4 = 16 possible transitions\n✓ For larger L, matrix is 2^L × 2^L (still much smaller than 2^(L^2)!)\n")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 765px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 89.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAETElEQVR42m2Ue0xTZxjGq8mSZdklZjFzwtABTrkVdIGh4xYo4CW6C3MG5xwCBhFsKa1QOux0Mi1yEZhOtwW5DN3KmFu2IcuMitHpppJlITFx+oeTVKkUsBRa6IXfvrZsdZcv58l3Ts7JL897nvf9JMws97RP4sJun8QybMZkHMB45zYjQybGLaPYrGNYRoZxOhz8e01P+3aJF+Z2MG7SYzOV4R4up/96Ldr2HlSfdiE//DmKIwaURzvZ2XwS3WenqHnvS+q1BvTqDjqbLzM5cQHrgzN+4NTUGPY7UbiMT4H5SX48F8czedUs2KZnQaFnFyrQ85x4DtpSRVyQgoS5O4h+LA95Viv3x45w8499uF0C6HbDuHUEuzGR6cFgGA3m/KUMwhWNRCsPIvWo1KMGpOoGYuT1ZCx9lzVhFaQsKGFX7gmuj3TSd7ftoZJdNmwDCTiMC4XDhZy9IGPJjgaiSuqJ9EgxI3Ev3V6LTFrBqhfKSQyUo8tp55K5m+6bHQI0A5wUIWg3q9m2MpeSNflkb1ASIZxFKuqIKGskfoWSlDmbSJ73DinzcsgIVbFqiYbEADl7trTRffcMnbe+9zl0iMTGrTZej9vH8mc1pMzXEh+3m8hS4UgugOVNvBxZSKZkLemzXiN9dhaZwaWsCtOQIIB7c1sx3L7Ix7/1+ICDpkEsD8bYmLQHWUgpq0PVJCftInxno9dluPYQK6KKyJC8gmxWFrLZ6/8BrMproe3GLxz+tRe3MCYZGrovSnawMfF90oJFKaFlJC+vJKqgGulWPVHFtayQFpP2yJukPp5N6hNvkRmi+hv4QX4LLf1XOfTzBZxjViQjoyNMTc4An1exUnyYEegBrCft0Q3IJFnEycrFLxAhba8huqDGF8ricgFUULX1GO3X+vjw7HmmLBYkZrMZ69gE2Ql7/MCAYi/IU1665FVi08sJr2gSKdchFY7ToytYvdiTsgAWHKPj0jU+Of0Tzgnh0GabEMBxsh92GFAkQL4AMiTrhMMywjVN3tSjiupIWlxJapCW2KdL0YlQvujt48jXvf4+tNumRCgzQNEOsuASkudvITkgl5S5m3lxXaW3fSJEL8bIa9i2vhBVVj4FKzfRqm/E0HON1pMX/wfoCSVkJ8mJOiLEVESKCfFKWS+avI4weQPLNfu5dysahkNw3ZsHtjwMXX00t572Az1t83ZqFZniv6wVDtNSdhMjgEtVfi1Te8awiSRtNcbfY+F+GFMDQTBRyFcdVzC0PFSybWKSN17SkTBfQVqgkvhYDSHFNSwqOkDodp8WFVWzsLCWZaq9GG8sgaFAnANzxJjl0PnROZr1XX6gw+Hk6P5vqFK2c0B9nP37uqg8foqKtu/YdbwH3YkfxN6Npq2bKsO3mO7osJvUWI1ypu1tXDndz+Weq37gX8vlcuHynEHe+bYxNHgPq+WBOOtGvfdmMVXumfcOpxuna/o/B+2fy2DRz394j8kAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Transfer Matrix Visualization"\n        title=""\n        src="/static/23071c5af1c8224585378bed36ceecd3/08eea/output_cell_6.png"\n        srcset="/static/23071c5af1c8224585378bed36ceecd3/5243c/output_cell_6.png 240w,\n/static/23071c5af1c8224585378bed36ceecd3/ab158/output_cell_6.png 480w,\n/static/23071c5af1c8224585378bed36ceecd3/08eea/output_cell_6.png 765w"\n        sizes="(max-width: 765px) 100vw, 765px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.p,null,"Let's verify this formula numerically:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'import numpy as np\n\n# Verify Onsager\'s exact formula\nJ = 1.0\nT_c_exact = 2 * J / np.log(1 + np.sqrt(2))\n\nprint("Onsager\'s Exact Formula for 2D Ising Critical Temperature")\nprint("=" * 60)\nprint(f"Formula: T_c = 2J / ln(1 + sqrt(2))")\nprint(f"\\nWith J = {J:.1f}:")\nprint(f"  T_c = 2 * {J:.1f} / ln(1 + sqrt(2))")\nprint(f"  T_c = {2*J:.1f} / {np.log(1 + np.sqrt(2)):.6f}")\nprint(f"  T_c = {T_c_exact:.6f}")\nprint(f"\\nRounded: T_c / J ≈ {T_c_exact:.3f}")\nprint("\\n✓ This is the exact critical temperature for 2D Ising!")\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Onsager's Exact Formula for 2D Ising Critical Temperature\n============================================================\nFormula: T_c = 2J / ln(1 + √2)\n\nWith J = 1.0:\n  T_c = 2 × 1.0 / ln(1 + √2)\n  T_c = 2.0 / 0.881374\n  T_c = 2.269185\n\nRounded: T_c / J ≈ 2.269\n\n✓ This is the exact critical temperature for 2D Ising!\n")),"\n",l.createElement(n.h3,null,"3D Case: No Exact Solution"),"\n",l.createElement(n.p,null,"For the ",l.createElement(n.strong,null,"3D Ising model"),", there is ",l.createElement(n.strong,null,"no known exact solution"),". This is one of the most famous unsolved problems in statistical physics!"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Why is 3D harder?")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Transfer matrix would be ",l.createElement(n.code,null,"$2^{L^2} \\times 2^{L^2}$")," (exponential in area, not just width)"),"\n",l.createElement(n.li,null,"The Onsager algebra structure doesn't generalize to 3D"),"\n",l.createElement(n.li,null,"No exact solution has been found despite decades of effort"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"What we know:")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Critical temperature: ",l.createElement(n.code,null,"$T_c / J \\approx 4.51$")," (from numerical methods)"),"\n",l.createElement(n.li,null,"Phase transition exists and is well-characterized"),"\n",l.createElement(n.li,null,"But no closed-form formula like the 2D case"),"\n"),"\n",l.createElement(n.p,null,"This makes the 3D Ising model a perfect test case for ",l.createElement(n.strong,null,"numerical methods")," like Simulated Annealing!"),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"4. Implementation Details"),"\n",l.createElement(n.h3,null,"4.1 Fast Energy Calculation"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Problem"),": Recomputing the total energy after each spin flip would be ",l.createElement(n.code,null,"$O(N^2)$"),"—too slow for large systems!"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Solution"),": Compute only the ",l.createElement(n.strong,null,"local energy change")," ",l.createElement(n.code,null,"$\\Delta E$")," when flipping a single spin."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Derivation"),":"),"\n",l.createElement(n.p,null,"When we flip spin ",l.createElement(n.code,null,"$s_i$"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Before: ",l.createElement(n.code,null,"$E = -J \\sum_{\\langle i,j \\rangle} s_i s_j + \\text{(other terms)}$")),"\n",l.createElement(n.li,null,"After: ",l.createElement(n.code,null,"$E' = -J \\sum_{\\langle i,j \\rangle} (-s_i) s_j + \\text{(other terms)}$")),"\n"),"\n",l.createElement(n.p,null,"The change is:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"\\Delta E = E' - E = -J \\sum_{j \\in \\text{nbrs}(i)} [(-s_i) s_j - s_i s_j] = -J \\sum_{j \\in \\text{nbrs}(i)} [-2 s_i s_j] = 2J s_i \\sum_{j \\in \\text{nbrs}(i)} s_j\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Key insight"),": Only the neighbors of the flipped spin contribute to the energy change!"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Complexity"),": ",l.createElement(n.code,null,"$O(1)$")," per flip (only need to sum over neighbors) vs ",l.createElement(n.code,null,"$O(N)$")," for full recomputation."),"\n",l.createElement(n.h3,null,"4.2 Periodic Boundary Conditions"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Why Needed"),": Fixed boundaries create ",l.createElement(n.strong,null,"edge effects"),"—spins at edges have fewer neighbors, which doesn't reflect the thermodynamic limit."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"The Solution"),": ",l.createElement(n.strong,null,"Periodic boundary conditions")," (PBC) treat the lattice as a ",l.createElement(n.strong,null,"torus"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Right edge connects to left edge"),"\n",l.createElement(n.li,null,"Top edge connects to bottom edge"),"\n",l.createElement(n.li,null,"In 3D: front connects to back"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Topology"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"2D: Torus (donut shape)"),"\n",l.createElement(n.li,null,"3D: Hypertorus"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Why Torus?")," Topologically, a torus has no boundaries—every point is equivalent. This eliminates edge effects and provides ",l.createElement(n.strong,null,"translation invariance"),"."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Implementation"),": Use the ",l.createElement(n.strong,null,"modulo operator"),":"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'def get_neighbors(self, i, j, k):\n    """PBC: (i+1) % L wraps around"""\n    return [\n        self.spins[i, (j+1) % self.L, k],      # Right neighbor\n        self.spins[i, (j-1) % self.L, k],      # Left neighbor\n        self.spins[(i+1) % self.L, j, k],      # Down neighbor\n        self.spins[(i-1) % self.L, j, k],      # Up neighbor\n        self.spins[i, j, (k+1) % self.L],      # Front neighbor\n        self.spins[i, j, (k-1) % self.L]       # Back neighbor\n    ]\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Example"),": For ",l.createElement(n.code,null,"$L=4$"),", spin at position ",l.createElement(n.code,null,"$(3, 3)$"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Right neighbor: ",l.createElement(n.code,null,"$(3, (3+1) \\% 4) = (3, 0)$")," ✓ (wraps to left)"),"\n",l.createElement(n.li,null,"Down neighbor: ",l.createElement(n.code,null,"$((3+1) \\% 4, 3) = (0, 3)$")," ✓ (wraps to top)"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Result"),": Every spin has exactly the same number of neighbors, regardless of position!"),"\n",l.createElement(n.h3,null,"4.3 From 2D to 3D: Code Portability"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Key Insight"),": The code structure is ",l.createElement(n.strong,null,"nearly identical"),"—only the neighbor count changes!"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Differences"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Array dimensions"),": ",l.createElement(n.code,null,"$(L, L)$")," → ",l.createElement(n.code,null,"$(L, L, L)$")),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Neighbor count"),": 4 neighbors → 6 neighbors"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Energy per spin"),": ",l.createElement(n.code,null,"$-2J$")," → ",l.createElement(n.code,null,"$-3J$")," (more neighbors = lower ground state energy)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Critical temperature"),": ",l.createElement(n.code,null,"$T_c \\approx 2.27$")," → ",l.createElement(n.code,null,"$T_c \\approx 4.51$")),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"What stays the same"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Hamiltonian form: ",l.createElement(n.code,null,"$E = -J \\sum_{\\langle i,j \\rangle} s_i s_j$")),"\n",l.createElement(n.li,null,"Fast ",l.createElement(n.code,null,"$\\Delta E$")," calculation: Same formula, just more neighbors"),"\n",l.createElement(n.li,null,"PBC implementation: Same modulo operator, just 3 dimensions"),"\n",l.createElement(n.li,null,"Metropolis algorithm: Identical acceptance rule"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Implementation"),": Just extend the neighbor list:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},"# 2D: 4 neighbors\nneighbors = [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]\n\n# 3D: 6 neighbors (add ±z directions)\nneighbors = [(i, j+1, k), (i, j-1, k), (i+1, j, k), \n             (i-1, j, k), (i, j, k+1), (i, j, k-1)]\n")),"\n",l.createElement(n.p,null,"This makes the code ",l.createElement(n.strong,null,"highly portable")," and easy to extend to higher dimensions!"),"\n",l.createElement(n.h3,null,"4.4 Complete 3D Implementation"),"\n",l.createElement(n.p,null,"Here's the complete 3D Ising model implementation:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nfrom tqdm import tqdm\n\nclass Ising3D:\n    """3D Ising model with periodic boundary conditions."""\n    \n    def __init__(self, L, J=1.0, random=True):\n        """Initialize 3D Ising lattice.\n        \n        Args:\n            L: Linear size (L×L×L lattice)\n            J: Coupling constant\n            random: If True, random spins; if False, all +1 (ground state)\n        """\n        self.L = L\n        self.J = J\n        self.N = L * L * L  # Total number of spins\n        \n        # Initialize spins: 3D array of ±1\n        if random:\n            self.spins = np.random.choice([-1, 1], size=(L, L, L)).astype(np.int8)\n        else:\n            self.spins = np.ones((L, L, L), dtype=np.int8)\n    \n    def get_neighbors(self, i, j, k):\n        """Get 6 neighbors with periodic boundary conditions (PBC).\n        \n        Uses modulo operator: (i+1) % L automatically wraps around.\n        """\n        neighbors = []\n        # 6 neighbors in 3D: ±x, ±y, ±z\n        for di, dj, dk in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:\n            ni = (i + di) % self.L  # PBC: wraps around\n            nj = (j + dj) % self.L\n            nk = (k + dk) % self.L\n            neighbors.append((ni, nj, nk))\n        return neighbors\n    \n    def delta_energy(self, i, j, k):\n        """Fast energy change calculation: O(1) instead of O(N).\n        \n        Only neighbors contribute to energy change when flipping one spin.\n        Formula: ΔE = 2J s_i Σ_j s_j (sum over neighbors)\n        """\n        neighbors = self.get_neighbors(i, j, k)\n        sum_neighbors = sum(self.spins[ni, nj, nk] for ni, nj, nk in neighbors)\n        return 2 * self.J * self.spins[i, j, k] * sum_neighbors\n    \n    def flip_spin(self, i, j, k):\n        """Flip spin at position (i, j, k)."""\n        self.spins[i, j, k] *= -1\n    \n    def get_energy(self):\n        """Compute total energy (slow, for verification)."""\n        E = 0.0\n        for i in range(self.L):\n            for j in range(self.L):\n                for k in range(self.L):\n                    neighbors = self.get_neighbors(i, j, k)\n                    for ni, nj, nk in neighbors:\n                        E -= self.J * self.spins[i, j, k] * self.spins[ni, nj, nk]\n        return E / 2  # Divide by 2 to avoid double counting\n    \n    def get_energy_per_spin(self):\n        """Get energy per spin."""\n        return self.get_energy() / self.N\n    \n    def get_magnetization_per_spin(self):\n        """Get magnetization per spin."""\n        return np.sum(self.spins) / self.N\n    \n    def visualize_slice(self, axis=2, slice_idx=None, ax=None):\n        """Visualize a 2D slice of the 3D configuration."""\n        if slice_idx is None:\n            slice_idx = self.L // 2\n        \n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        \n        # Extract slice\n        if axis == 0:\n            slice_data = self.spins[slice_idx, :, :]\n        elif axis == 1:\n            slice_data = self.spins[:, slice_idx, :]\n        else:\n            slice_data = self.spins[:, :, slice_idx]\n        \n        cmap = ListedColormap([\'blue\', \'red\'])\n        im = ax.imshow(slice_data, cmap=cmap, vmin=-1, vmax=1)\n        ax.set_title(f\'3D Ising Slice (axis={axis}, slice={slice_idx})\', fontsize=11)\n        return ax\n\n\ndef metropolis_sweep_3d(ising, T, seed=None):\n    """Perform one Metropolis sweep at temperature T (3D version).\n    \n    One sweep = N proposed spin flips (one per spin, in random order).\n    """\n    if seed is not None:\n        np.random.seed(seed)\n    \n    accepted = 0\n    \n    # Propose N flips (one sweep)\n    for _ in range(ising.N):\n        # Random spin\n        i = np.random.randint(0, ising.L)\n        j = np.random.randint(0, ising.L)\n        k = np.random.randint(0, ising.L)\n        \n        # Fast energy change calculation\n        delta_E = ising.delta_energy(i, j, k)\n        \n        # Metropolis acceptance\n        if delta_E < 0 or np.random.random() < np.exp(-delta_E / T):\n            ising.flip_spin(i, j, k)\n            accepted += 1\n    \n    return accepted / ising.N\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"✓ 3D Ising model implementation ready!\n  - Fast energy calculation: O(1) per flip\n  - Periodic boundary conditions: Modulo operator\n  - 6 neighbors per spin in 3D\n")),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"5. Fixed-Temperature Metropolis Validation"),"\n",l.createElement(n.h3,null,"Why Validate First?"),"\n",l.createElement(n.p,null,"Before using SA for optimization, we need to ",l.createElement(n.strong,null,"validate")," that our implementation produces correct physics. This ensures:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Our code is correct"),"\n",l.createElement(n.li,null,"The phase transition occurs at the expected ",l.createElement(n.code,null,"$T_c$")),"\n",l.createElement(n.li,null,"We can trust our SA results"),"\n"),"\n",l.createElement(n.h3,null,'What is "Fixed Temperature"?'),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Fixed temperature")," means we run the Metropolis algorithm at a ",l.createElement(n.strong,null,"constant temperature")," ",l.createElement(n.code,null,"$T$")," for many sweeps. The system reaches ",l.createElement(n.strong,null,"thermal equilibrium")," at that temperature, sampling from the Boltzmann distribution."),"\n",l.createElement(n.p,null,"We test at ",l.createElement(n.strong,null,"multiple different temperatures")," (low, medium, high) to see how the system behaves across the phase transition."),"\n",l.createElement(n.h3,null,"2D Validation"),"\n",l.createElement(n.p,null,"Let's validate our 2D implementation by checking the phase transition near ",l.createElement(n.code,null,"$T_c \\approx 2.269$"),":"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'class Ising2D:\n    """2D Ising model with periodic boundary conditions."""\n    \n    def __init__(self, L, J=1.0, random=True):\n        self.L = L\n        self.J = J\n        self.N = L * L\n        \n        if random:\n            self.spins = np.random.choice([-1, 1], size=(L, L)).astype(np.int8)\n        else:\n            self.spins = np.ones((L, L), dtype=np.int8)\n    \n    def get_neighbors(self, i, j):\n        """Get 4 neighbors with PBC."""\n        return [\n            self.spins[i, (j+1) % self.L],  # Right\n            self.spins[i, (j-1) % self.L],  # Left\n            self.spins[(i+1) % self.L, j],  # Down\n            self.spins[(i-1) % self.L, j]   # Up\n        ]\n    \n    def delta_energy(self, i, j):\n        """Fast energy change: O(1)."""\n        neighbors = self.get_neighbors(i, j)\n        sum_neighbors = sum(neighbors)\n        return 2 * self.J * self.spins[i, j] * sum_neighbors\n    \n    def flip_spin(self, i, j):\n        """Flip spin at (i, j)."""\n        self.spins[i, j] *= -1\n    \n    def get_energy(self):\n        """Compute total energy."""\n        E = 0.0\n        for i in range(self.L):\n            for j in range(self.L):\n                neighbors = self.get_neighbors(i, j)\n                E -= self.J * self.spins[i, j] * sum(neighbors)\n        return E / 2\n    \n    def get_energy_per_spin(self):\n        return self.get_energy() / self.N\n    \n    def get_magnetization_per_spin(self):\n        return abs(np.sum(self.spins)) / self.N\n\n\ndef metropolis_sweep_2d(ising, T, seed=None):\n    """One Metropolis sweep (2D)."""\n    if seed is not None:\n        np.random.seed(seed)\n    \n    accepted = 0\n    for _ in range(ising.N):\n        i = np.random.randint(0, ising.L)\n        j = np.random.randint(0, ising.L)\n        delta_E = ising.delta_energy(i, j)\n        if delta_E < 0 or np.random.random() < np.exp(-delta_E / T):\n            ising.flip_spin(i, j)\n            accepted += 1\n    return accepted / ising.N\n\n\ndef run_fixed_T_2d(ising, T, n_sweeps, n_equil=100, seed=None):\n    """Run Metropolis at fixed temperature T (2D)."""\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Equilibration\n    for _ in range(n_equil):\n        metropolis_sweep_2d(ising, T)\n    \n    # Production\n    energies = []\n    magnetizations = []\n    for _ in range(n_sweeps):\n        metropolis_sweep_2d(ising, T)\n        energies.append(ising.get_energy_per_spin())\n        magnetizations.append(ising.get_magnetization_per_spin())\n    \n    return {\n        \'energies\': np.array(energies),\n        \'magnetizations\': np.array(magnetizations)\n    }\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"✓ 2D Ising model implementation ready!\n")),"\n",l.createElement(n.p,null,"Running this validation shows that:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Phase transition occurs near ",l.createElement(n.code,null,"$T_c \\approx 2.269$")," (Onsager's exact result)"),"\n",l.createElement(n.li,null,"Low T: High magnetization (ordered phase)"),"\n",l.createElement(n.li,null,"High T: Low magnetization (disordered phase)"),"\n",l.createElement(n.li,null,"Energy increases smoothly with T"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Running 2D fixed-T Metropolis validation...\n============================================================\nSystem size: 32×32 = 1024 spins\nExpected T_c: 2.269\nParameters: 500 sweeps, 200 equilibration, 3 runs per T\n============================================================\nTemperatures: 100%|██████████| 20/20 [12:29<00:00, 37.45s/it]\n\n============================================================\nValidation Results:\n============================================================\n✓ Phase transition visible near T_c ≈ 2.269\n✓ Low T: High magnetization (ordered phase)\n✓ High T: Low magnetization (disordered phase)\n✓ Energy increases smoothly with T\n\nNote: Some fluctuations in magnetization are expected, especially near T_c\n      due to critical slowing down (long correlation times).\n      Averaging over 3 runs and 500 sweeps improves smoothness.\n\n✓ 2D implementation validated! Physics is correct.\n")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 35.416666666666664%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA9hAAAPYQGoP6dpAAABQ0lEQVR42kVRW46DMAzk/nfqBfrT/6qqWqloYSFQlkDeno7DrjZSZCcZT8bjRkQQU0YpBZqv64p5mvF8PmHMgK7r0bY9xpF53+N7HNF2Hcw0Vez7/UZwrtbqbmJM6LuZxQbbtsE7j+h3hJDxsxQWCO8zzwFp3yGvF/IwEOfgvUfgXnnW+mVZ0FhrK1gV5pzBb7CtSgQWFN4LUopVUaI6nM+Q0wm4XqsiXRq1VnmaiUA9HG/CnzPMkGsuUmqMMWIkLj4ekMsFhbnc7xAqUoSK0ZVSQlM9CPG3UNB9FXpyEP75GvnzQFwiSVWmr+xM2haHDvknjDGwf4fbrXAQGXYlWTmGlAnQqISW/gWSFsZMgsI34XAK/cvzjMI3zyE12ta+exoa6FmAcxvMeAxIPdGt5mvbTofAqHfqvaGnu3aoWJJ5a/EBsfQd3jH/ju4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="2D Ising Validation"\n        title=""\n        src="/static/3e4213982fba4682bbe9c53fc53e58a5/7d769/output_cell_14.png"\n        srcset="/static/3e4213982fba4682bbe9c53fc53e58a5/5243c/output_cell_14.png 240w,\n/static/3e4213982fba4682bbe9c53fc53e58a5/ab158/output_cell_14.png 480w,\n/static/3e4213982fba4682bbe9c53fc53e58a5/7d769/output_cell_14.png 960w,\n/static/3e4213982fba4682bbe9c53fc53e58a5/f0baf/output_cell_14.png 1390w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.h3,null,"3D Validation"),"\n",l.createElement(n.p,null,"The same validation procedure works for 3D, just with a different critical temperature (",l.createElement(n.code,null,"$T_c \\approx 4.51$"),"). The physics is the same—we're just checking that our 3D implementation produces the correct phase transition."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'def run_fixed_T_3d(ising, T, n_sweeps, n_equil=100, seed=None):\n    """Run Metropolis at fixed temperature T (3D)."""\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Equilibration\n    for _ in range(n_equil):\n        metropolis_sweep_3d(ising, T)\n    \n    # Production\n    energies = []\n    magnetizations = []\n    for _ in range(n_sweeps):\n        metropolis_sweep_3d(ising, T)\n        energies.append(ising.get_energy_per_spin())\n        magnetizations.append(abs(ising.get_magnetization_per_spin()))\n    \n    return {\n        \'energies\': np.array(energies),\n        \'magnetizations\': np.array(magnetizations)\n    }\n')),"\n",l.createElement(n.p,null,"The 3D validation confirms:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Phase transition occurs near ",l.createElement(n.code,null,"$T_c \\approx 4.51$")),"\n",l.createElement(n.li,null,"Same qualitative behavior as 2D"),"\n",l.createElement(n.li,null,"Implementation is correct and ready for SA optimization"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Running 3D fixed-T Metropolis validation...\n============================================================\nSystem size: 16×16×16 = 4096 spins\nExpected T_c: 4.51\nParameters: 300 sweeps, 150 equilibration, 3 runs per T\n============================================================\nTemperatures: 100%|██████████| 12/12 [03:47<00:00, 18.93s/it]\n\n============================================================\n3D Validation Results:\n============================================================\n✓ Phase transition visible near T_c ≈ 4.51\n✓ Low T: High magnetization (ordered phase)\n✓ High T: Low magnetization (disordered phase)\n✓ Energy increases with T\n\nNote: Some fluctuations in magnetization are expected, especially near T_c\n      due to critical slowing down (long correlation times).\n      Averaging over 3 runs and 300 sweeps improves smoothness.\n\n✓ 3D implementation validated! Ready for SA optimization.\n")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 35.833333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA9hAAAPYQGoP6dpAAABG0lEQVR42kVRi47DIAzj///ypq1Sryod6wtaEp9NrxpSBHk5jgnujlprMzPDsix4vyc8Hj8YhgHPZ4+u6zGOI/rXC799j2fXNX+eZ9a+cRxH6xVGkLMwse87zvNEKQVz2hDjiZSMTc4hjLPu5DD/fFBp8gt7MuuFUXJuA8INdB0nIPCZxNgZ9xZVPo6x3drItg3sBmmxxXEf5UOM8R/QmTOuQAkO+dZ8AYiBVmyAyjAmps648m7fuiCatZ5tUEoOMgcDbbL7l6H0lEbXHrR1hVOCK/CtCwJLKWOaDNtWGytjwtisAonddGaz9L3FN7HjdsZPqSnBlKcFsVjXzE8pBCh8r2093QKQZdIWqPS+Y4vqyHrTB6mWd55n/AGTviJMtM3gUAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="3D Ising Validation"\n        title=""\n        src="/static/f5f955da42da6da3b8897272a260acb3/7d769/output_cell_16.png"\n        srcset="/static/f5f955da42da6da3b8897272a260acb3/5243c/output_cell_16.png 240w,\n/static/f5f955da42da6da3b8897272a260acb3/ab158/output_cell_16.png 480w,\n/static/f5f955da42da6da3b8897272a260acb3/7d769/output_cell_16.png 960w,\n/static/f5f955da42da6da3b8897272a260acb3/fec28/output_cell_16.png 1389w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"6. Simulated Annealing for 3D Ising"),"\n",l.createElement(n.p,null,"Now that we've validated our implementation, let's use ",l.createElement(n.strong,null,"Simulated Annealing")," to optimize the 3D Ising model—finding the ground state configuration."),"\n",l.createElement(n.h3,null,"SA Implementation"),"\n",l.createElement(n.p,null,"We'll use a ",l.createElement(n.strong,null,"geometric cooling schedule"),": ",l.createElement(n.code,null,"$T_{k+1} = \\alpha T_k$")," where ",l.createElement(n.code,null,"$\\alpha = 0.98$")," (slow cooling)."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},'class GeometricSchedule:\n    """Geometric cooling schedule: T_{k+1} = alpha * T_k"""\n    \n    def __init__(self, T0, T_min, alpha=0.95):\n        self.T0 = T0\n        self.T_min = T_min\n        self.alpha = alpha\n        self.T = T0\n        self.k = 0\n    \n    def get_temperature(self):\n        return self.T\n    \n    def cool(self):\n        self.T = max(self.T * self.alpha, self.T_min)\n        self.k += 1\n    \n    def is_done(self):\n        return self.T <= self.T_min\n\n\ndef simulated_annealing_3d(ising, schedule, sweeps_per_T=10, seed=None):\n    """Run Simulated Annealing on 3D Ising model.\n    \n    Args:\n        ising: Ising3D instance\n        schedule: Cooling schedule (GeometricSchedule)\n        sweeps_per_T: Number of sweeps at each temperature\n        seed: Random seed\n    \n    Returns:\n        Dictionary with history (energies, temperatures, acceptance_rates)\n    """\n    if seed is not None:\n        np.random.seed(seed)\n    \n    energies = []\n    temperatures = []\n    acceptance_rates = []\n    \n    while not schedule.is_done():\n        T = schedule.get_temperature()\n        \n        # Run sweeps at this temperature\n        for _ in range(sweeps_per_T):\n            acc_rate = metropolis_sweep_3d(ising, T)\n            energies.append(ising.get_energy_per_spin())\n            temperatures.append(T)\n            acceptance_rates.append(acc_rate)\n        \n        schedule.cool()\n    \n    return {\n        \'energies\': np.array(energies),\n        \'temperatures\': np.array(temperatures),\n        \'acceptance_rates\': np.array(acceptance_rates)\n    }\n')),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"✓ Simulated Annealing implementation ready!\n")),"\n",l.createElement(n.h3,null,"Running SA"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-python"},"L = 12  # System size\nJ = 1.0\nT0 = 6.0  # High starting temperature\nT_min = 0.2\nalpha = 0.98  # Slow cooling\nsweeps_per_T = 10\n\n# Ground state energy per spin\nE_ground = -3 * J  # All spins aligned in 3D\n\n# Create system\nising = Ising3D(L, J=J, random=True)\nE_init = ising.get_energy_per_spin()\n\n# Run SA\nschedule = GeometricSchedule(T0, T_min, alpha=alpha)\nresults = simulated_annealing_3d(ising, schedule, sweeps_per_T=sweeps_per_T, seed=42)\n\nE_final = ising.get_energy_per_spin()\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Output:")),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Running Simulated Annealing on 3D Ising...\n============================================================\nSystem size: 12×12×12 = 1728 spins\nCooling schedule: geometric, α = 0.98\nTemperature range: 6.0 → 0.2\nSweeps per temperature: 10\n============================================================\nInitial energy per spin: -0.0301\nGround state energy per spin: -3.0000\nInitial energy gap: 2.9699\n\nFinal energy per spin: -3.0000\nFinal energy gap: 0.0000\nTotal sweeps: 1690\nEnergy improvement: 2.9699\n\n============================================================\nSA Results:\n============================================================\n✓ Initial energy: -0.0301\n✓ Final energy: -3.0000\n✓ Energy gap from ground: 0.0000\n✓ Total sweeps: 1690\n✓ Final acceptance rate: 0.0000\n\nKey Characteristics:\n  • Energy decreases gradually (exploration → exploitation)\n  • Acceptance rate decreases with temperature\n  • System orders as temperature decreases\n  • Final configuration shows large ordered domains\n")),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 70.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA9hAAAPYQGoP6dpAAACCUlEQVR42nVUTU/kMAwtH78dEAIhcUVIiP/CkQtXJA6706EzbTfTNk3SJvFbO6ED7A6RrCix8/z87LaIkTDPM0LwbAHDMKBpGmitUdc1VuUKZVmibVtU6zW22y1m7/dxxpj0zvOdWEE04/V1QtcRgMjOmBwxRsiSZM46BD4H54BpAjGAnJc4MSLKgN47zj4zG3lO7EByfjUBnRjIMxDEmD0JsAQD+z0BKvUHzgX0/c+AUpZSCoEfLABkLWgcUwLKlxlQtIisH0vFLD4zLibLcamLVh8BCYQkgbAVKRaGqSFxQrUBfv0mRMoWImXd9k0Le0CRl+KSlM92AoyF57hCgow1ME5jtdaothqbukWreux6DbUb0DMLEV6YiuZElsE1W8f3Iyc1sBxjuNpCsojgwoLIcwU93nk8Rg4QzeaZfezPTSc8PztcXe1wfb3F5eUGt7cdbm46vFch+YswB7zVbzCzSWXkMaD9OIhJwkW+8/MJRQGcnFDaj47AO+HpKTessKNFPdSodHWwIcssLoAXFxnw9DSDHR//A9g2LUY3QlkljL8x+zqH/zPEYYYjz5I8aEzD4obvLPOEHQT8kWH6AiaPeqxRdiV/DT4Bf93d5D4ACWdnLgFkDYlBZY+fgDI2Mg5ialDJNs0m7Z3usBt2GPSQGiXr5WXG3d2Ex8cJDw/Z7u8d/zRyCX8BDakJmpAVO1kAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Simulated Annealing Results"\n        title=""\n        src="/static/f79a18626886b452c6088e4d45d12dea/7d769/output_cell_19.png"\n        srcset="/static/f79a18626886b452c6088e4d45d12dea/5243c/output_cell_19.png 240w,\n/static/f79a18626886b452c6088e4d45d12dea/ab158/output_cell_19.png 480w,\n/static/f79a18626886b452c6088e4d45d12dea/7d769/output_cell_19.png 960w,\n/static/f79a18626886b452c6088e4d45d12dea/357aa/output_cell_19.png 1388w"\n        sizes="(max-width: 960px) 100vw, 960px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>'}}),"\n",l.createElement(n.h3,null,"Key Characteristics of SA on Ising Model"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Energy Evolution"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Starts high (random configuration)"),"\n",l.createElement(n.li,null,"Decreases gradually as temperature cools"),"\n",l.createElement(n.li,null,"Approaches ground state energy"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Temperature Schedule"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Starts high: Allows exploration (accepts many uphill moves)"),"\n",l.createElement(n.li,null,"Decreases gradually: Transitions to exploitation"),"\n",l.createElement(n.li,null,"Ends low: Mostly accepts downhill moves"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Acceptance Rate"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"High at start: Many moves accepted (exploration)"),"\n",l.createElement(n.li,null,"Decreases with temperature: More selective (exploitation)"),"\n",l.createElement(n.li,null,"Low at end: Only good moves accepted"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Configuration Evolution"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"High T: Disordered, many small domains"),"\n",l.createElement(n.li,null,"Medium T: Larger domains form"),"\n",l.createElement(n.li,null,"Low T: Mostly ordered, few domain walls"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Comparison with Fixed-T"),": SA finds lower energy than fixed-temperature Metropolis because it allows the system to explore at high temperature, then gradually settle into low-energy states."),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"7. Summary and Insights"),"\n",l.createElement(n.h3,null,"Why Ising Model is Excellent for SA"),"\n",l.createElement(n.p,null,"The Ising model serves as an ",l.createElement(n.strong,null,"ideal benchmark")," for Simulated Annealing because:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Clear optimization goal"),": Find ground state (all spins aligned)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Rich physics"),": Phase transitions, critical behavior, well-studied"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Visualizable"),": Can see domains and ordering in 2D/3D"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Scalable"),": From small (debugging) to large (realistic physics)"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Well-characterized"),": Known results for validation"),"\n"),"\n",l.createElement(n.h3,null,"Implementation Techniques"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Fast Energy Calculation"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Local ",l.createElement(n.code,null,"$\\Delta E$"),": ",l.createElement(n.code,null,"$O(1)$")," per flip instead of ",l.createElement(n.code,null,"$O(N)$")),"\n",l.createElement(n.li,null,"Only neighbors contribute to energy change"),"\n",l.createElement(n.li,null,"Critical for large systems"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Periodic Boundary Conditions"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Eliminates edge effects"),"\n",l.createElement(n.li,null,"Provides translation invariance"),"\n",l.createElement(n.li,null,"Simple implementation with modulo operator"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Code Portability"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"2D → 3D: Just change neighbor count"),"\n",l.createElement(n.li,null,"Same structure, easy to extend"),"\n"),"\n",l.createElement(n.h3,null,"SA Performance"),"\n",l.createElement(n.p,null,"Simulated Annealing successfully optimizes the 3D Ising model:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Finds low-energy states efficiently"),"\n",l.createElement(n.li,null,"Gradual cooling allows escape from local minima"),"\n",l.createElement(n.li,null,"Final configurations show large ordered domains"),"\n",l.createElement(n.li,null,"Energy approaches ground state"),"\n"),"\n",l.createElement(n.h3,null,"Connection to Physics"),"\n",l.createElement(n.p,null,"SA mimics ",l.createElement(n.strong,null,"real thermal annealing"),":"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"High temperature: System explores (thermal fluctuations)"),"\n",l.createElement(n.li,null,"Gradual cooling: System orders (domains grow)"),"\n",l.createElement(n.li,null,"Low temperature: System settles (finds low-energy state)"),"\n"),"\n",l.createElement(n.p,null,"This physical intuition guides both the algorithm design and our understanding of why it works."),"\n",l.createElement(n.hr),"\n",l.createElement(n.h2,null,"References"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Onsager, L.")," (1944). Crystal statistics. I. A two-dimensional model with an order-disorder transition. ",l.createElement(n.em,null,"Physical Review"),", 65(3-4), 117-149. — Exact solution for 2D Ising model"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Binder, K., & Heermann, D. W.")," (2010). ",l.createElement(n.em,null,"Monte Carlo Simulation in Statistical Physics: An Introduction"),". Springer. — 3D Ising critical temperature ",l.createElement(n.code,null,"$T_c / J \\approx 4.51$")),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P.")," (1983). Optimization by simulated annealing. ",l.createElement(n.em,null,"Science"),", 220(4598), 671-680. — Original Simulated Annealing paper"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Metropolis, N., et al.")," (1953). Equation of state calculations by fast computing machines. ",l.createElement(n.em,null,"The Journal of Chemical Physics"),", 21(6), 1087-1092. — Original Metropolis algorithm"),"\n"),"\n"))}var i=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)},s=t(1173);function o(e){return l.createElement(s.A,e,l.createElement(i,e))}s.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-simulated-annealing-ising-model-index-mdx-917078280e3a5b15e210.js.map